[
  {
    "content": "What does the &quot;yield&quot; keyword do in Python?",
    "chosen": "<p>To understand what <a href=\"https://docs.python.org/3/reference/simple_stmts.html#yield\" rel=\"noreferrer\"><code>yield</code></a> does, you must understand what <em><a href=\"https://docs.python.org/3/glossary.html#term-generator\" rel=\"noreferrer\">generators</a></em> are. And before you can understand generators, you must understand <em><a href=\"https://docs.python.org/3/glossary.html#term-iterable\" rel=\"noreferrer\">iterables</a></em>.</p>\n<h2>Iterables</h2>\n<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</p>\n<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n1\n2\n3\n</code></pre>\n<p><code>mylist</code> is an <em>iterable</em>. When you use a list comprehension, you create a list, and so an iterable:</p>\n<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n0\n1\n4\n</code></pre>\n<p>Everything you can use &quot;<code>for... in...</code>&quot; on is an iterable; <code>lists</code>, <code>strings</code>, files...</p>\n<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</p>\n<h2>Generators</h2>\n<p>Generators are <em><a href=\"https://docs.python.org/3/glossary.html#term-iterator\" rel=\"noreferrer\">iterators</a></em>, a kind of iterable <strong>you can only iterate over once</strong>. Generators do not store all the values in memory, <strong>they generate the values on the fly</strong>:</p>\n<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator:\n...    print(i)\n0\n1\n4\n</code></pre>\n<p>It is just the same except you used <code>()</code> instead of <code>[]</code>. BUT, you <strong>cannot</strong> perform <code>for i in mygenerator</code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.</p>\n<h2>Yield</h2>\n<p><code>yield</code> is a keyword that is used like <code>return</code>, except the function will return a generator.</p>\n<pre><code>&gt;&gt;&gt; def create_generator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = create_generator() # create a generator\n&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!\n&lt;generator object create_generator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4\n</code></pre>\n<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</p>\n<p>To master <code>yield</code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.</strong> The function only returns the generator object, this is a bit tricky.</p>\n<p>Then, your code will continue from where it left off each time <code>for</code> uses the generator.</p>\n<p>Now the hard part:</p>\n<p>The first time the <code>for</code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield</code>, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting <code>yield</code>. That can be because the loop has come to an end, or because you no longer satisfy an <code>&quot;if/else&quot;</code>.</p>\n<hr />\n<h2>Your code explained</h2>\n<p><em>Generator:</em></p>\n<pre><code># Here you create the method of the node object that will return the generator\ndef _get_child_candidates(self, distance, min_dist, max_dist):\n\n    # Here is the code that will be called each time you use the generator object:\n\n    # If there is still a child of the node object on its left\n    # AND if the distance is ok, return the next child\n    if self._leftchild and distance - max_dist &lt; self._median:\n        yield self._leftchild\n\n    # If there is still a child of the node object on its right\n    # AND if the distance is ok, return the next child\n    if self._rightchild and distance + max_dist &gt;= self._median:\n        yield self._rightchild\n\n    # If the function arrives here, the generator will be considered empty\n    # There are no more than two values: the left and the right children\n</code></pre>\n<p><em>Caller:</em></p>\n<pre><code># Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning)\nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If the distance is ok, then you can fill in the result\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate to the candidate's list\n    # so the loop will keep running until it has looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n</code></pre>\n<p>This code contains several smart parts:</p>\n<ul>\n<li><p>The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> exhausts all the values of the generator, but <code>while</code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</p>\n</li>\n<li><p>The <code>extend()</code> method is a list object method that expects an iterable and adds its values to the list.</p>\n</li>\n</ul>\n<p>Usually, we pass a list to it:</p>\n<pre><code>&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; a.extend(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n</code></pre>\n<p>But in your code, it gets a generator, which is good because:</p>\n<ol>\n<li>You don't need to read the values twice.</li>\n<li>You may have a lot of children and you don't want them all stored in memory.</li>\n</ol>\n<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</p>\n<p>You can stop here, or read a little bit to see an advanced use of a generator:</p>\n<h2>Controlling a generator exhaustion</h2>\n<pre><code>&gt;&gt;&gt; class Bank(): # Let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield &quot;$100&quot;\n&gt;&gt;&gt; hsbc = Bank() # When everything's ok the ATM gives you as much as you want\n&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n&gt;&gt;&gt; hsbc.crisis = True # Crisis is coming, no more money!\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # It's even true for new ATMs\n&gt;&gt;&gt; print(wall_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # Build a new one to get back in business\n&gt;&gt;&gt; for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n</code></pre>\n<p><strong>Note:</strong> For Python 3, use<code>print(corner_street_atm.__next__())</code> or <code>print(next(corner_street_atm))</code></p>\n<p>It can be useful for various things like controlling access to a resource.</p>\n<h2>Itertools, your best friend</h2>\n<p>The <code>itertools</code> module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one-liner? <code>Map / Zip</code> without creating another list?</p>\n<p>Then just <code>import itertools</code>.</p>\n<p>An example? Let's see the possible orders of arrival for a four-horse race:</p>\n<pre><code>&gt;&gt;&gt; horses = [1, 2, 3, 4]\n&gt;&gt;&gt; races = itertools.permutations(horses)\n&gt;&gt;&gt; print(races)\n&lt;itertools.permutations object at 0xb754f1dc&gt;\n&gt;&gt;&gt; print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n</code></pre>\n<h2>Understanding the inner mechanisms of iteration</h2>\n<p>Iteration is a process implying iterables (implementing the <code>__iter__()</code> method) and iterators (implementing the <code>__next__()</code> method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</p>\n<p>There is more about it in this article about <a href=\"https://web.archive.org/web/20201109034340/http://effbot.org/zone/python-for-statement.htm\" rel=\"noreferrer\">how <code>for</code> loops work</a>.</p>\n",
    "rejected": "\n<p>The <code>yield</code> keyword is reduced to two simple facts:</p>\n<ol>\n<li>If the compiler detects the <code>yield</code> keyword <em>anywhere</em> inside a function, that function no longer returns via the <code>return</code> statement. <em><strong>Instead</strong></em>, it <strong>immediately</strong> returns a <strong>lazy &quot;pending list&quot; object</strong> called a generator</li>\n<li>A generator is iterable. What is an <em>iterable</em>? It's anything like a <code>list</code>, <code>set</code>, <code>range</code>, dictionary view, or any other object with a <em>built-in protocol for visiting each element in a certain order</em>.</li>\n</ol>\n<p>In a nutshell: Most commonly, <strong>a generator is a lazy, incrementally-pending list</strong>, and <strong><code>yield</code> statements allow you to use function notation to program the list values</strong> the generator should incrementally spit out. <strong>Furthermore, advanced usage lets you use generators as coroutines (see below).</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code>generator = myYieldingFunction(...)  # basically a list (but lazy)\nx = list(generator)  # evaluate every element into a list\n\n   generator\n       v\n[x[0], ..., ???]\n\n         generator\n             v\n[x[0], x[1], ..., ???]\n\n               generator\n                   v\n[x[0], x[1], x[2], ..., ???]\n\n                       StopIteration exception\n[x[0], x[1], x[2]]     done\n</code></pre>\n<p>Basically, whenever the <code>yield</code> statement is encountered, the function pauses and saves its state, then emits &quot;the next return value in the 'list'&quot; according to the python iterator protocol (to some syntactic construct like a for-loop that repeatedly calls <code>next()</code> and catches a <code>StopIteration</code> exception, etc.). You might have encountered generators with <a href=\"https://www.python.org/dev/peps/pep-0289/\" rel=\"noreferrer\">generator expressions</a>; generator functions are more powerful because you can pass arguments back into the paused generator function, using them to implement coroutines. More on that later.</p>\n<hr />\n<h2>Basic Example ('list')</h2>\n<p>Let's define a function <code>makeRange</code> that's just like Python's <code>range</code>. Calling <code>makeRange(n)</code> RETURNS A GENERATOR:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def makeRange(n):\n    # return 0,1,2,...,n-1\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n&gt;&gt;&gt; makeRange(5)\n&lt;generator object makeRange at 0x19e4aa0&gt;\n</code></pre>\n<p>To force the generator to immediately return its pending values, you can pass it into <code>list()</code> (just like you could any iterable):</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; list(makeRange(5))\n[0, 1, 2, 3, 4]\n</code></pre>\n<hr />\n<h2>Comparing the example to &quot;just returning a list&quot;</h2>\n<p>The above example can be thought of as merely creating a list that you append to and return:</p>\n<pre class=\"lang-py prettyprint-override\"><code># return a list                  #  # return a generator\ndef makeRange(n):                #  def makeRange(n):\n    &quot;&quot;&quot;return [0,1,2,...,n-1]&quot;&quot;&quot; #      &quot;&quot;&quot;return 0,1,2,...,n-1&quot;&quot;&quot;\n    TO_RETURN = []               # \n    i = 0                        #      i = 0\n    while i &lt; n:                 #      while i &lt; n:\n        TO_RETURN += [i]         #          yield i\n        i += 1                   #          i += 1\n    return TO_RETURN             # \n\n&gt;&gt;&gt; makeRange(5)\n[0, 1, 2, 3, 4]\n</code></pre>\n<p>There is one major difference, though; see the last section.</p>\n<hr />\n<h2>How you might use generators</h2>\n<p>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code>#                  &lt; ITERABLE &gt;\n&gt;&gt;&gt; [x+10 for x in makeRange(5)]\n[10, 11, 12, 13, 14]\n</code></pre>\n<p>To get a better feel for generators, you can play around with the <code>itertools</code> module (be sure to use <code>chain.from_iterable</code> rather than <code>chain</code> when warranted). For example, you might even use generators to implement infinitely-long lazy lists like <code>itertools.count()</code>. You could implement your own <code>def enumerate(iterable): zip(count(), iterable)</code>, or alternatively do so with the <code>yield</code> keyword in a while-loop.</p>\n<p>Please note: generators can actually be used for many more things, such as <a href=\"http://www.dabeaz.com/coroutines/index.html\" rel=\"noreferrer\">implementing coroutines</a>, non-deterministic programming, and other elegant things. However, the &quot;lazy lists&quot; viewpoint I present here is the most common use you will find.</p>\n<hr />\n<h2>Behind the scenes</h2>\n<p>This is how the &quot;Python iteration protocol&quot; works. That is, what is going on when you do <code>list(makeRange(5))</code>. This is what I describe earlier as a &quot;lazy, incremental list&quot;.</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x=iter(range(5))\n&gt;&gt;&gt; next(x)  # calls x.__next__(); x.next() is deprecated\n0\n&gt;&gt;&gt; next(x)\n1\n&gt;&gt;&gt; next(x)\n2\n&gt;&gt;&gt; next(x)\n3\n&gt;&gt;&gt; next(x)\n4\n&gt;&gt;&gt; next(x)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nStopIteration\n</code></pre>\n<p>The built-in function <code>next()</code> just calls the objects <code>.__next__()</code> function, which is a part of the &quot;iteration protocol&quot; and is found on all iterators. You can manually use the <code>next()</code> function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</p>\n<hr />\n<h2>Coroutines</h2>\n<p><a href=\"https://www.python.org/dev/peps/pep-0342/\" rel=\"noreferrer\">Coroutine</a> example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def interactiveProcedure():\n    userResponse = yield makeQuestionWebpage()\n    print('user response:', userResponse)\n    yield 'success'\n\ncoroutine = interactiveProcedure()\nwebFormData = next(coroutine)  # same as .send(None)\nuserResponse = serveWebForm(webFormData)\n\n# ...at some point later on web form submit...\n\nsuccessStatus = coroutine.send(userResponse)\n</code></pre>\n<p>A coroutine (generators that generally accept input via the <code>yield</code> keyword e.g. <code>nextInput = yield nextOutput</code>, as a form of two-way communication) is basically a computation that is allowed to pause itself and request input (e.g. to what it should do next). When the coroutine pauses itself (when the running coroutine eventually hits a <code>yield</code> keyword), the computation is paused and control is inverted (yielded) back to the 'calling' function (the frame which requested the <code>next</code> value of the computation). The paused generator/coroutine remains paused until another invoking function (possibly a different function/context) requests the next value to unpause it (usually passing input data to direct the paused logic interior to the coroutine's code).</p>\n<p><strong>You can think of Python coroutines as lazy incrementally-pending lists, where the next element doesn't just depend on the previous computation but also on input that you may opt to inject during the generation process.</strong></p>\n<hr />\n<h2>Minutiae</h2>\n<p>Normally, most people would not care about the following distinctions and probably want to stop reading here.</p>\n<p>In Python-speak, an <em>iterable</em> is any object which &quot;understands the concept of a for-loop&quot; like a list <code>[1,2,3]</code>, and an <em>iterator</em> is a specific instance of the requested for-loop like <code>[1,2,3].__iter__()</code>. A <em>generator</em> is exactly the same as any iterator, except for the way it was written (with function syntax).</p>\n<p>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</p>\n<p>Thus, in the unlikely event that you are failing to do something like this...</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt; x = myRange(5)\n&gt; list(x)\n[0, 1, 2, 3, 4]\n&gt; list(x)\n[]\n</code></pre>\n<p>... then remember that a generator is an <em>iterator</em>; that is, it is one-time-use. If you want to reuse it, you should call <code>myRange(...)</code> again. If you need to use the result twice, convert the result to a list and store it in a variable <code>x = list(myRange(5))</code>. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use <a href=\"https://docs.python.org/2/library/itertools.html#itertools.tee\" rel=\"noreferrer\"><code>itertools.tee</code></a> (<a href=\"https://docs.python.org/3/library/itertools.html#itertools.tee\" rel=\"noreferrer\">still works in Python 3</a>) if absolutely necessary, since the <a href=\"https://www.python.org/dev/peps/pep-0323/\" rel=\"noreferrer\">copyable iterator Python PEP standards proposal</a> has been deferred.</p>\n"
  },
  {
    "content": "What does if __name__ == &quot;__main__&quot;: do?",
    "chosen": "<h1>Short Answer</h1>\n<p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:</p>\n<ul>\n<li><p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard</code>), then the latter script will trigger the former to run <em>at import time</em> and <em>using the second script's command line arguments</em>. This is almost always a mistake.</p>\n</li>\n<li><p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.</p>\n</li>\n</ul>\n<h1>Long Answer</h1>\n<p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.</p>\n<p>Whenever the Python interpreter reads a source file, it does two things:</p>\n<ul>\n<li><p>it sets a few special variables like <code>__name__</code>, and then</p>\n</li>\n<li><p>it executes all of the code found in the file.</p>\n</li>\n</ul>\n<p>Let's see how this works and how it relates to your question about the <code>__name__</code> checks we always see in Python scripts.</p>\n<h2>Code Sample</h2>\n<p>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called <code>foo.py</code>.</p>\n<pre><code># Suppose this is foo.py.\n\nprint(&quot;before import&quot;)\nimport math\n\nprint(&quot;before function_a&quot;)\ndef function_a():\n    print(&quot;Function A&quot;)\n\nprint(&quot;before function_b&quot;)\ndef function_b():\n    print(&quot;Function B {}&quot;.format(math.sqrt(100)))\n\nprint(&quot;before __name__ guard&quot;)\nif __name__ == '__main__':\n    function_a()\n    function_b()\nprint(&quot;after __name__ guard&quot;)\n</code></pre>\n<h2>Special Variables</h2>\n<p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__</code> variable.</p>\n<p><strong>When Your Module Is the Main Program</strong></p>\n<p>If you are running your module (the source file) as the main program, e.g.</p>\n<pre><code>python foo.py\n</code></pre>\n<p>the interpreter will assign the hard-coded string <code>&quot;__main__&quot;</code> to the <code>__name__</code> variable, i.e.</p>\n<pre><code># It's as if the interpreter inserts this at the top\n# of your module when run as the main program.\n__name__ = &quot;__main__&quot; \n</code></pre>\n<p><strong>When Your Module Is Imported By Another</strong></p>\n<p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</p>\n<pre><code># Suppose this is in some other main program.\nimport foo\n</code></pre>\n<p>The interpreter will search for your <code>foo.py</code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>&quot;foo&quot;</code> from the import statement to the <code>__name__</code> variable, i.e.</p>\n<pre><code># It's as if the interpreter inserts this at the top\n# of your module when it's imported from another module.\n__name__ = &quot;foo&quot;\n</code></pre>\n<h2>Executing the Module's Code</h2>\n<p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</p>\n<p><strong>Always</strong></p>\n<ol>\n<li><p>It prints the string <code>&quot;before import&quot;</code> (without quotes).</p>\n</li>\n<li><p>It loads the <code>math</code> module and assigns it to a variable called <code>math</code>. This is equivalent to replacing <code>import math</code> with the following (note that <code>__import__</code> is a low-level function in Python that takes a string and triggers the actual import):</p>\n</li>\n</ol>\n<pre><code># Find and load a module given its string name, &quot;math&quot;,\n# then assign it to a local variable called math.\nmath = __import__(&quot;math&quot;)\n</code></pre>\n<ol start=\"3\">\n<li><p>It prints the string <code>&quot;before function_a&quot;</code>.</p>\n</li>\n<li><p>It executes the <code>def</code> block, creating a function object, then assigning that function object to a variable called <code>function_a</code>.</p>\n</li>\n<li><p>It prints the string <code>&quot;before function_b&quot;</code>.</p>\n</li>\n<li><p>It executes the second <code>def</code> block, creating another function object, then assigning it to a variable called <code>function_b</code>.</p>\n</li>\n<li><p>It prints the string <code>&quot;before __name__ guard&quot;</code>.</p>\n</li>\n</ol>\n<p><strong>Only When Your Module Is the Main Program</strong></p>\n<ol start=\"8\">\n<li>If your module is the main program, then it will see that <code>__name__</code> was indeed set to <code>&quot;__main__&quot;</code> and it calls the two functions, printing the strings <code>&quot;Function A&quot;</code> and <code>&quot;Function B 10.0&quot;</code>.</li>\n</ol>\n<p><strong>Only When Your Module Is Imported by Another</strong></p>\n<ol start=\"8\">\n<li>(<strong>instead</strong>) If your module is not the main program but was imported by another one, then <code>__name__</code> will be <code>&quot;foo&quot;</code>, not <code>&quot;__main__&quot;</code>, and it'll skip the body of the <code>if</code> statement.</li>\n</ol>\n<p><strong>Always</strong></p>\n<ol start=\"9\">\n<li>It will print the string <code>&quot;after __name__ guard&quot;</code> in both situations.</li>\n</ol>\n<p><em><strong>Summary</strong></em></p>\n<p>In summary, here's what'd be printed in the two cases:</p>\n<pre class=\"lang-none prettyprint-override\"><code># What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code># What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n</code></pre>\n<h2>Why Does It Work This Way?</h2>\n<p>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a <code>.py</code> file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</p>\n<ul>\n<li><p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</p>\n</li>\n<li><p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py</code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</p>\n</li>\n<li><p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</p>\n</li>\n</ul>\n<p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. &quot;Running&quot; the script is a side effect of importing the script's module.</p>\n<h2>Food for Thought</h2>\n<ul>\n<li><p>Question: Can I have multiple <code>__name__</code> checking blocks?  Answer: it's strange to do so, but the language won't stop you.</p>\n</li>\n<li><p>Suppose the following is in <code>foo2.py</code>.  What happens if you say <code>python foo2.py</code> on the command-line? Why?</p>\n</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is foo2.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo2 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nif __name__ == &quot;__main__&quot;:\n    print(&quot;m1&quot;)\n    function_a()\n    print(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n      \n</code></pre>\n<ul>\n<li>Now, figure out what will happen in <code>foo3.py</code> (having removed the <code>__name__</code> check):</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is foo3.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(&quot;a1&quot;)\n    from foo3 import function_b\n    print(&quot;a2&quot;)\n    function_b()\n    print(&quot;a3&quot;)\n\ndef function_b():\n    print(&quot;b&quot;)\n\nprint(&quot;t1&quot;)\nprint(&quot;m1&quot;)\nfunction_a()\nprint(&quot;m2&quot;)\nprint(&quot;t2&quot;)\n</code></pre>\n<ul>\n<li>What will this do when used as a script?  When imported as a module?</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code># Suppose this is in foo4.py\n__name__ = &quot;__main__&quot;\n\ndef bar():\n    print(&quot;bar&quot;)\n    \nprint(&quot;before __name__ guard&quot;)\nif __name__ == &quot;__main__&quot;:\n    bar()\nprint(&quot;after __name__ guard&quot;)\n</code></pre>\n",
    "rejected": "<blockquote>\n  <h2>What does the <code>if __name__ == \"__main__\":</code> do?</h2>\n</blockquote>\n\n<p>To outline the basics:</p>\n\n<ul>\n<li><p>The global variable, <code>__name__</code>, in the module that is the entry point to your program, is <code>'__main__'</code>. Otherwise, it's the name you import the module by.</p></li>\n<li><p>So, code under the <code>if</code> block will only run if the module is the entry point to your program.</p></li>\n<li><p>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</p></li>\n</ul>\n\n<hr>\n\n<p>Why do we need this?</p>\n\n<h2>Developing and Testing Your Code</h2>\n\n<p>Say you're writing a Python script designed to be used as a module:</p>\n\n<pre><code>def do_important():\n    \"\"\"This function does something very important\"\"\"\n</code></pre>\n\n<p>You <em>could</em> test the module by adding this call of the function to the bottom:</p>\n\n<pre><code>do_important()\n</code></pre>\n\n<p>and running it (on a command prompt) with something like:</p>\n\n<pre><code>~$ python important.py\n</code></pre>\n\n<h2>The Problem</h2>\n\n<p>However, if you want to import the module to another script:</p>\n\n<pre><code>import important\n</code></pre>\n\n<p>On import, the <code>do_important</code> function would be called, so you'd probably comment out your function call, <code>do_important()</code>, at the bottom. </p>\n\n<pre><code># do_important() # I must remember to uncomment to execute this!\n</code></pre>\n\n<p>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</p>\n\n<h2>A Better Way</h2>\n\n<p>The <code>__name__</code> variable points to the namespace wherever the Python interpreter happens to be at the moment. </p>\n\n<p>Inside an imported module, it's the name of that module. </p>\n\n<p>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its <code>\"__main__\"</code>.</p>\n\n<p>So if you check before executing:</p>\n\n<pre><code>if __name__ == \"__main__\":\n    do_important()\n</code></pre>\n\n<p>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script). </p>\n\n<h2>An Even Better Way</h2>\n\n<p>There's a Pythonic way to improve on this, though. </p>\n\n<p>What if we want to run this business process from outside the module?</p>\n\n<p>If we put the code we want to exercise as we develop and test in a function like this and then do our check for <code>'__main__'</code> immediately after:</p>\n\n<pre><code>def main():\n    \"\"\"business logic for when running this module as the primary one!\"\"\"\n    setup()\n    foo = do_important()\n    bar = do_even_more_important(foo)\n    for baz in bar:\n        do_super_important(baz)\n    teardown()\n\n# Here's our payoff idiom!\nif __name__ == '__main__':\n    main()\n</code></pre>\n\n<p>We now have a final function for the end of our module that will run if we run the module as the primary module. </p>\n\n<p>It will allow the module and its functions and classes to be imported into other scripts without running the <code>main</code> function, and will also allow the module (and its functions and classes) to be called when running from a different <code>'__main__'</code> module, i.e.</p>\n\n<pre><code>import important\nimportant.main()\n</code></pre>\n\n<p><a href=\"https://docs.python.org/2/library/__main__.html\" rel=\"noreferrer\">This idiom can also be found in the Python documentation in an explanation of the <code>__main__</code> module.</a> That text states:</p>\n\n<blockquote>\n  <p>This module represents the (otherwise anonymous) scope in which the\n  interpreter’s main program executes — commands read either from\n  standard input, from a script file, or from an interactive prompt. It\n  is this environment in which the idiomatic “conditional script” stanza\n  causes a script to run:</p>\n\n<pre><code>if __name__ == '__main__':\n    main()\n</code></pre>\n</blockquote>\n"
  },
  {
    "content": "Does Python have a ternary conditional operator?",
    "chosen": "<p>Yes, it was <a href=\"https://mail.python.org/pipermail/python-dev/2005-September/056846.html\" rel=\"noreferrer\" title=\"[Python-Dev] Conditional Expression Resolution\">added</a> in version 2.5. The expression syntax is:</p>\n<pre class=\"lang-py prettyprint-override\"><code>a if condition else b\n</code></pre>\n<p>First <code>condition</code> is evaluated, then exactly one of either <code>a</code> or <code>b</code> is evaluated and returned based on the <a href=\"https://en.wikipedia.org/wiki/Boolean_data_type\" rel=\"noreferrer\" title=\"Boolean data type\">Boolean</a> value of <code>condition</code>. If <code>condition</code> evaluates to <code>True</code>, then <code>a</code> is evaluated and returned but <code>b</code> is ignored, or else when <code>b</code> is evaluated and returned but <code>a</code> is ignored.</p>\n<p>This allows short-circuiting because when <code>condition</code> is true only <code>a</code> is evaluated and <code>b</code> is not evaluated at all, but when <code>condition</code> is false only <code>b</code> is evaluated and <code>a</code> is not evaluated at all.</p>\n<p>For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; 'true' if True else 'false'\n'true'\n&gt;&gt;&gt; 'true' if False else 'false'\n'false'\n</code></pre>\n<p>Note that conditionals are an <em>expression</em>, not a <em>statement</em>. This means you can't use <strong>statements</strong> such as <code>pass</code>, or assignments with <code>=</code> (or &quot;augmented&quot; assignments like <code>+=</code>), within a conditional <strong>expression</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; pass if False else pass\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    pass if False else pass\n         ^\nSyntaxError: invalid syntax\n\n&gt;&gt;&gt; # Python parses this as `x = (1 if False else y) = 2`\n&gt;&gt;&gt; # The `(1 if False else x)` part is actually valid, but\n&gt;&gt;&gt; # it can't be on the left-hand side of `=`.\n&gt;&gt;&gt; x = 1 if False else y = 2\n  File &quot;&lt;stdin&gt;&quot;, line 1\nSyntaxError: cannot assign to conditional expression\n\n&gt;&gt;&gt; # If we parenthesize it instead...\n&gt;&gt;&gt; (x = 1) if False else (y = 2)\n  File &quot;&lt;stdin&gt;&quot;, line 1\n    (x = 1) if False else (y = 2)\n       ^\nSyntaxError: invalid syntax\n</code></pre>\n<p>(In 3.8 and above, the <code>:=</code> &quot;walrus&quot; operator allows simple assignment of values <em>as an expression</em>, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)</p>\n<p>Similarly, because it is an expression, the <code>else</code> part is <em>mandatory</em>:</p>\n<pre><code># Invalid syntax: we didn't specify what the value should be if the \n# condition isn't met. It doesn't matter if we can verify that\n# ahead of time.\na if True\n</code></pre>\n<p>You can, however, use conditional expressions to assign a variable like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code>x = a if True else b\n</code></pre>\n<p>Or for example to return a value:</p>\n<pre><code># Of course we should just use the standard library `max`;\n# this is just for demonstration purposes.\ndef my_max(a, b):\n    return a if a &gt; b else b\n</code></pre>\n<p>Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will <em>do the same thing</em> with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to <em>do something different</em> depending on the condition, then use a normal <code>if</code> <strong>statement</strong> instead.</p>\n<hr />\n<p>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</p>\n<ul>\n<li>The order of the arguments is different from those of the classic <code>condition ? a : b</code> ternary operator from many other languages (such as <a href=\"https://en.wikipedia.org/wiki/C_%28programming_language%29\" rel=\"noreferrer\">C</a>, <a href=\"https://en.wikipedia.org/wiki/C%2B%2B\" rel=\"noreferrer\">C++</a>, <a href=\"https://en.wikipedia.org/wiki/Go_%28programming_language%29\" rel=\"noreferrer\">Go</a>, <a href=\"https://en.wikipedia.org/wiki/Perl\" rel=\"noreferrer\">Perl</a>, <a href=\"https://en.wikipedia.org/wiki/Ruby_%28programming_language%29\" rel=\"noreferrer\">Ruby</a>, <a href=\"https://en.wikipedia.org/wiki/Java_%28programming_language%29\" rel=\"noreferrer\">Java</a>, <a href=\"https://en.wikipedia.org/wiki/JavaScript\" rel=\"noreferrer\">JavaScript</a>, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</li>\n<li>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</li>\n<li>Stylistic reasons. (Although the 'inline <code>if</code>' can be <em>really</em> useful, and make your script more concise, it really does complicate your code)</li>\n</ul>\n<p>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, <code>x = 4 if b &gt; 8 else 9</code> is read aloud as <code>x will be 4 if b is greater than 8 otherwise 9</code>.</p>\n<p>Official documentation:</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/reference/expressions.html#conditional-expressions\" rel=\"noreferrer\" title=\"Conditional expressions\">Conditional expressions</a></li>\n<li><a href=\"https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator\" rel=\"noreferrer\" title=\"Is there an equivalent of C’s ”?:” ternary operator?\">Is there an equivalent of C’s ”?:” ternary operator?</a></li>\n</ul>\n",
    "rejected": "<p>You can index into a tuple:</p>\n\n<pre><code>(falseValue, trueValue)[test]\n</code></pre>\n\n<p><code>test</code> needs to return <em>True</em> or <em>False</em>.<br>\nIt might be safer to always implement it as:</p>\n\n<pre><code>(falseValue, trueValue)[test == True]\n</code></pre>\n\n<p>or you can use the built-in <a href=\"https://docs.python.org/3.3/library/functions.html#bool\" rel=\"noreferrer\" title=\"bool\"><code>bool()</code></a> to assure a <a href=\"https://en.wikipedia.org/wiki/Boolean_data_type\" rel=\"noreferrer\" title=\"Boolean data type\">Boolean</a> value:</p>\n\n<pre><code>(falseValue, trueValue)[bool(&lt;expression&gt;)]\n</code></pre>\n"
  },
  {
    "content": "What are metaclasses in Python?",
    "chosen": "<h1>Classes are objects</h1>\n<p>Before delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language.</p>\n<p>In most languages, classes are descriptions of how to create an object. That is somewhat true in Python too:</p>\n<pre><code>&gt;&gt;&gt; class ObjectCreator(object):\n...     pass\n\n&gt;&gt;&gt; my_object = ObjectCreator()\n&gt;&gt;&gt; print(my_object)\n    &lt;__main__.ObjectCreator object at 0x8974f2c&gt;\n</code></pre>\n<p>But classes are more than that in Python. <strong>Classes are objects too.</strong></p>\n<p>Yes, objects.</p>\n<p>When a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the <code>class</code> keyword, Python creates an <strong>object</strong> out of the &quot;description&quot; of the class that follows. Thus, the following instruction</p>\n<pre><code>&gt;&gt;&gt; class ObjectCreator(object):\n...     pass\n</code></pre>\n<p>...creates an <em>object</em> with the name <code>ObjectCreator</code>!</p>\n<p>This object (the class) is itself capable of creating objects (called <em>instances</em>).</p>\n<p>But still, it's an object. Therefore, like all objects:</p>\n<ul>\n<li><p>you can assign it to a variable<sup>1</sup></p>\n<pre><code>JustAnotherVariable = ObjectCreator\n</code></pre>\n</li>\n<li><p>you can attach attributes to it</p>\n<pre><code>ObjectCreator.class_attribute = 'foo'\n</code></pre>\n</li>\n<li><p>you can pass it as a function parameter</p>\n<pre><code>print(ObjectCreator)\n</code></pre>\n</li>\n</ul>\n<p><sup>1</sup> Note that merely assigning it to another variable doesn't change the class's <code>__name__</code>, i.e.,</p>\n<pre><code>&gt;&gt;&gt; print(JustAnotherVariable)\n    &lt;class '__main__.ObjectCreator'&gt;\n\n&gt;&gt;&gt; print(JustAnotherVariable())\n    &lt;__main__.ObjectCreator object at 0x8997b4c&gt;\n</code></pre>\n\n<h1>Creating classes dynamically</h1>\n<p>Since classes are objects, you can create them on the fly, like any object.</p>\n<p>First, you can create a class in a function using <code>class</code>:</p>\n<pre><code>&gt;&gt;&gt; def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n\n&gt;&gt;&gt; MyClass = choose_class('foo')\n\n&gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance\n    &lt;class '__main__.Foo'&gt;\n\n&gt;&gt;&gt; print(MyClass()) # you can create an object from this class\n    &lt;__main__.Foo object at 0x89c6d4c&gt;\n</code></pre>\n<p>But it's not so dynamic, since you still have to write the whole class yourself.</p>\n<p>Since classes are objects, they must be generated by something.</p>\n<p>When you use the <code>class</code> keyword, Python creates this object automatically. But as\nwith most things in Python, it gives you a way to do it manually.</p>\n<p>Remember the function <code>type</code>? The good old function that lets you know what\ntype an object is:</p>\n<pre><code>&gt;&gt;&gt; print(type(1))\n    &lt;class 'int'&gt;\n\n&gt;&gt;&gt; print(type(&quot;1&quot;))\n    &lt;class 'str'&gt;\n\n&gt;&gt;&gt; print(type(ObjectCreator))\n    &lt;class 'type'&gt;\n\n&gt;&gt;&gt; print(type(ObjectCreator()))\n    &lt;class '__main__.ObjectCreator'&gt;\n</code></pre>\n<p>Well, <a href=\"http://docs.python.org/2/library/functions.html#type\" rel=\"noreferrer\"><code>type</code></a> also has a completely different ability: it can create classes on the fly. <code>type</code> can take the description of a class as parameters,\nand return a class.</p>\n<p>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward\ncompatibility in Python)</p>\n<p><code>type</code> works this way:</p>\n<pre><code>type(name, bases, attrs)\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><strong><code>name</code></strong>: name of the class</li>\n<li><strong><code>bases</code></strong>: tuple of the parent class (for inheritance, can be empty)</li>\n<li><strong><code>attrs</code></strong>: dictionary containing attributes names and values</li>\n</ul>\n<p>e.g.:</p>\n<pre><code>&gt;&gt;&gt; class MyShinyClass(object):\n...     pass\n</code></pre>\n<p>can be created manually this way:</p>\n<pre><code>&gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n&gt;&gt;&gt; print(MyShinyClass)\n    &lt;class '__main__.MyShinyClass'&gt;\n\n&gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class\n    &lt;__main__.MyShinyClass object at 0x8997cec&gt;\n</code></pre>\n<p>You'll notice that we use <code>MyShinyClass</code> as the name of the class\nand as the variable to hold the class reference. They can be different,\nbut there is no reason to complicate things.</p>\n<p><code>type</code> accepts a dictionary to define the attributes of the class. So:</p>\n<pre><code>&gt;&gt;&gt; class Foo(object):\n...     bar = True\n</code></pre>\n<p>Can be translated to:</p>\n<pre><code>&gt;&gt;&gt; Foo = type('Foo', (), {'bar':True})\n</code></pre>\n<p>And used as a normal class:</p>\n<pre><code>&gt;&gt;&gt; print(Foo)\n    &lt;class '__main__.Foo'&gt;\n\n&gt;&gt;&gt; print(Foo.bar)\n    True\n\n&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; print(f)\n    &lt;__main__.Foo object at 0x8a9b84c&gt;\n\n&gt;&gt;&gt; print(f.bar)\n    True\n</code></pre>\n<p>And of course, you can inherit from it, so:</p>\n<pre><code>&gt;&gt;&gt; class FooChild(Foo):\n...     pass\n</code></pre>\n<p>would be:</p>\n<pre><code>&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})\n&gt;&gt;&gt; print(FooChild)\n    &lt;class '__main__.FooChild'&gt;\n\n&gt;&gt;&gt; print(FooChild.bar) # bar is inherited from Foo\n    True\n</code></pre>\n<p>Eventually, you'll want to add methods to your class. Just define a function\nwith the proper signature and assign it as an attribute.</p>\n<pre><code>&gt;&gt;&gt; def echo_bar(self):\n...     print(self.bar)\n\n&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n\n&gt;&gt;&gt; hasattr(Foo, 'echo_bar')\n    False\n\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar')\n    True\n\n&gt;&gt;&gt; my_foo = FooChild()\n&gt;&gt;&gt; my_foo.echo_bar()\n    True\n</code></pre>\n<p>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</p>\n<pre><code>&gt;&gt;&gt; def echo_bar_more(self):\n...     print('yet another method')\n\n&gt;&gt;&gt; FooChild.echo_bar_more = echo_bar_more\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar_more')\n    True\n</code></pre>\n<p>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</p>\n<p>This is what Python does when you use the keyword <code>class</code>, and it does so by using a metaclass.</p>\n<h1>What are metaclasses (finally)</h1>\n<p>Metaclasses are the 'stuff' that creates classes.</p>\n<p>You define classes in order to create objects, right?</p>\n<p>But we learned that Python classes are objects.</p>\n<p>Well, metaclasses are what create these objects. They are the classes' classes,\nyou can picture them this way:</p>\n<pre><code>MyClass = MetaClass()\nmy_object = MyClass()\n</code></pre>\n<p>You've seen that <code>type</code> lets you do something like this:</p>\n<pre><code>MyClass = type('MyClass', (), {})\n</code></pre>\n<p>It's because the function <code>type</code> is in fact a metaclass. <code>type</code> is the\nmetaclass Python uses to create all classes behind the scenes.</p>\n<p>Now you wonder &quot;why the heck is it written in lowercase, and not <code>Type</code>?&quot;</p>\n<p>Well, I guess it's a matter of consistency with <code>str</code>, the class that creates\nstrings objects, and <code>int</code> the class that creates integer objects. <code>type</code> is\njust the class that creates class objects.</p>\n<p>You see that by checking the <code>__class__</code> attribute.</p>\n<p>Everything, and I mean everything, is an object in Python. That includes integers,\nstrings, functions and classes. All of them are objects. And all of them have\nbeen created from a class:</p>\n<pre><code>&gt;&gt;&gt; age = 35\n&gt;&gt;&gt; age.__class__\n    &lt;type 'int'&gt;\n\n&gt;&gt;&gt; name = 'bob'\n&gt;&gt;&gt; name.__class__\n    &lt;type 'str'&gt;\n\n&gt;&gt;&gt; def foo(): pass\n&gt;&gt;&gt; foo.__class__\n    &lt;type 'function'&gt;\n\n&gt;&gt;&gt; class Bar(object): pass\n&gt;&gt;&gt; b = Bar()\n&gt;&gt;&gt; b.__class__\n    &lt;class '__main__.Bar'&gt;\n</code></pre>\n<p>Now, what is the <code>__class__</code> of any <code>__class__</code> ?</p>\n<pre><code>&gt;&gt;&gt; age.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; name.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; foo.__class__.__class__\n    &lt;type 'type'&gt;\n\n&gt;&gt;&gt; b.__class__.__class__\n    &lt;type 'type'&gt;\n</code></pre>\n<p>So, a metaclass is just the stuff that creates class objects.</p>\n<p>You can call it a 'class factory' if you wish.</p>\n<p><code>type</code> is the built-in metaclass Python uses, but of course, you can create your\nown metaclass.</p>\n<h1>The <a href=\"http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__\" rel=\"noreferrer\"><code>__metaclass__</code></a> attribute</h1>\n<p>In Python 2, you can add a <code>__metaclass__</code> attribute when you write a class (see next section for the Python 3 syntax):</p>\n<pre><code>class Foo(object):\n    __metaclass__ = something...\n    [...]\n</code></pre>\n<p>If you do so, Python will use the metaclass to create the class <code>Foo</code>.</p>\n<p>Careful, it's tricky.</p>\n<p>You write <code>class Foo(object)</code> first, but the class object <code>Foo</code> is not created\nin memory yet.</p>\n<p>Python will look for <code>__metaclass__</code> in the class definition. If it finds it,\nit will use it to create the class object <code>Foo</code>. If it doesn't, it will use\n<code>type</code> to create the class.</p>\n<p>Read that several times.</p>\n<p>When you do:</p>\n<pre><code>class Foo(Bar):\n    pass\n</code></pre>\n<p>Python does the following:</p>\n<p>Is there a <code>__metaclass__</code> attribute in <code>Foo</code>?</p>\n<p>If yes, create in-memory a class object (I said a class object, stay with me here), with the name <code>Foo</code> by using what is in <code>__metaclass__</code>.</p>\n<p>If Python can't find <code>__metaclass__</code>, it will look for a <code>__metaclass__</code> at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</p>\n<p>Then if it can't find any <code>__metaclass__</code> at all, it will use the <code>Bar</code>'s (the first parent) own metaclass (which might be the default <code>type</code>) to create the class object.</p>\n<p>Be careful here that the <code>__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__</code>) will be. If <code>Bar</code> used a <code>__metaclass__</code> attribute that created <code>Bar</code> with <code>type()</code> (and not <code>type.__new__()</code>), the subclasses will not inherit that behavior.</p>\n<p>Now the big question is, what can you put in <code>__metaclass__</code>?</p>\n<p>The answer is something that can create a class.</p>\n<p>And what can create a class? <code>type</code>, or anything that subclasses or uses it.</p>\n<h1>Metaclasses in Python 3</h1>\n<p>The syntax to set the metaclass has been changed in Python 3:</p>\n<pre><code>class Foo(object, metaclass=something):\n    ...\n</code></pre>\n<p>i.e. the <code>__metaclass__</code> attribute is no longer used, in favor of a keyword argument in the list of base classes.</p>\n<p>The behavior of metaclasses however stays <a href=\"https://www.python.org/dev/peps/pep-3115/\" rel=\"noreferrer\">largely the same</a>.</p>\n<p>One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</p>\n<pre><code>class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):\n    ...\n</code></pre>\n<p>Read the section below for how Python handles this.</p>\n<h1>Custom metaclasses</h1>\n<p>The main purpose of a metaclass is to change the class automatically,\nwhen it's created.</p>\n<p>You usually do this for APIs, where you want to create classes matching the\ncurrent context.</p>\n<p>Imagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase. There are several ways to\ndo this, but one way is to set <code>__metaclass__</code> at the module level.</p>\n<p>This way, all classes of this module will be created using this metaclass,\nand we just have to tell the metaclass to turn all attributes to uppercase.</p>\n<p>Luckily, <code>__metaclass__</code> can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be\na class, go figure... but it's helpful).</p>\n<p>So we will start with a simple example, by using a function.</p>\n<pre><code># the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attrs):\n    &quot;&quot;&quot;\n      Return a class object, with the list of its attribute turned\n      into uppercase.\n    &quot;&quot;&quot;\n    # pick up any attribute that doesn't start with '__' and uppercase it\n    uppercase_attrs = {\n        attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n        for attr, v in future_class_attrs.items()\n    }\n\n    # let `type` do the class creation\n    return type(future_class_name, future_class_parents, uppercase_attrs)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with &quot;object&quot; though\n    # but we can define __metaclass__ here instead to affect only this class\n    # and this will work with &quot;object&quot; children\n    bar = 'bip'\n</code></pre>\n<p>Let's check:</p>\n<pre><code>&gt;&gt;&gt; hasattr(Foo, 'bar')\n    False\n\n&gt;&gt;&gt; hasattr(Foo, 'BAR')\n    True\n\n&gt;&gt;&gt; Foo.BAR\n    'bip'\n</code></pre>\n<p>Now, let's do exactly the same, but using a real class for a metaclass:</p>\n<pre><code># remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type):\n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(\n        upperattr_metaclass,\n        future_class_name,\n        future_class_parents,\n        future_class_attrs\n    ):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in future_class_attrs.items()\n        }\n        return type(future_class_name, future_class_parents, uppercase_attrs)\n</code></pre>\n<p>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type(clsname, bases, uppercase_attrs)\n</code></pre>\n<p>You may have noticed the extra argument <code>cls</code>. There is\nnothing special about it: <code>__new__</code> always receives the class it's defined in, as the first parameter. Just like you have <code>self</code> for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.</p>\n<p>But this is not proper OOP. We are calling <code>type</code> directly and we aren't overriding or calling the parent's <code>__new__</code>. Let's do that instead:</p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type.__new__(cls, clsname, bases, uppercase_attrs)\n</code></pre>\n<p>We can make it even cleaner by using <code>super</code>, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</p>\n<pre><code>class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(&quot;__&quot;) else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n\n        # Python 2 requires passing arguments to super:\n        return super(UpperAttrMetaclass, cls).__new__(\n            cls, clsname, bases, uppercase_attrs)\n\n        # Python 3 can use no-arg super() which infers them:\n        return super().__new__(cls, clsname, bases, uppercase_attrs)\n</code></pre>\n<p>Oh, and in Python 3 if you do this call with keyword arguments, like this:</p>\n<pre><code>class Foo(object, metaclass=MyMetaclass, kwarg1=value1):\n    ...\n</code></pre>\n<p>It translates to this in the metaclass to use it:</p>\n<pre><code>class MyMetaclass(type):\n    def __new__(cls, clsname, bases, dct, kwarg1=default):\n        ...\n</code></pre>\n<p>That's it. There is really nothing more about metaclasses.</p>\n<p>The reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as <code>__dict__</code>, etc.</p>\n<p>Indeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated stuff. But by themselves, they are simple:</p>\n<ul>\n<li>intercept a class creation</li>\n<li>modify the class</li>\n<li>return the modified class</li>\n</ul>\n<h1>Why would you use metaclasses classes instead of functions?</h1>\n<p>Since <code>__metaclass__</code> can accept any callable, why would you use a class\nsince it's obviously more complicated?</p>\n<p>There are several reasons to do so:</p>\n<ul>\n<li>The intention is clear. When you read <code>UpperAttrMetaclass(type)</code>, you know\nwhat's going to follow</li>\n<li>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</li>\n<li>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</li>\n<li>You can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.</li>\n<li>You can hook on <code>__new__</code>, <code>__init__</code> and <code>__call__</code>. Which will allow you to do different stuff, Even if usually you can do it all in <code>__new__</code>,\nsome people are just more comfortable using <code>__init__</code>.</li>\n<li>These are called metaclasses, damn it! It must mean something!</li>\n</ul>\n<h1>Why would you use metaclasses?</h1>\n<p>Now the big question. Why would you use some obscure error-prone feature?</p>\n<p>Well, usually you don't:</p>\n<blockquote>\n<p>Metaclasses are deeper magic that\n99% of users should never worry about it.\nIf you wonder whether you need them,\nyou don't (the people who actually\nneed them know with certainty that\nthey need them, and don't need an\nexplanation about why).</p>\n</blockquote>\n<p><em>Python Guru Tim Peters</em></p>\n<p>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</p>\n<pre><code>class Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n</code></pre>\n<p>But if you do this:</p>\n<pre><code>person = Person(name='bob', age='35')\nprint(person.age)\n</code></pre>\n<p>It won't return an <code>IntegerField</code> object. It will return an <code>int</code>, and can even take it directly from the database.</p>\n<p>This is possible because <code>models.Model</code> defines <code>__metaclass__</code> and\nit uses some magic that will turn the <code>Person</code> you just defined with simple statements\ninto a complex hook to a database field.</p>\n<p>Django makes something complex look simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes.</p>\n<h1>The last word</h1>\n<p>First, you know that classes are objects that can create instances.</p>\n<p>Well, in fact, classes are themselves instances. Of metaclasses.</p>\n<pre><code>&gt;&gt;&gt; class Foo(object): pass\n&gt;&gt;&gt; id(Foo)\n    142630324\n</code></pre>\n<p>Everything is an object in Python, and they are all either instance of classes\nor instances of metaclasses.</p>\n<p>Except for <code>type</code>.</p>\n<p><code>type</code> is actually its own metaclass. This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel.</p>\n<p>Secondly, metaclasses are complicated. You may not want to use them for\nvery simple class alterations. You can change classes by using two different techniques:</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Monkey_patch\" rel=\"noreferrer\">monkey patching</a></li>\n<li>class decorators</li>\n</ul>\n<p>99% of the time you need class alteration, you are better off using these.</p>\n<p>But 98% of the time, you don't need class alteration at all.</p>\n",
    "rejected": "<p>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</p>\n\n<p>While in Python you can use arbitrary callables for metaclasses (like <a href=\"https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037\">Jerub</a> shows), the better approach is to make it an actual class itself. <code>type</code> is the usual metaclass in Python. <code>type</code> is itself a class, and it is its own type. You won't be able to recreate something like <code>type</code> purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass <code>type</code>.</p>\n\n<p>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal <code>__init__</code> and <code>__new__</code> methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</p>\n\n<p>When the <code>class</code> statement is executed, Python first executes the body of the <code>class</code> statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the <code>__metaclass__</code> attribute of the class-to-be (if any) or the <code>__metaclass__</code> global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</p>\n\n<p>However, metaclasses actually define the <em>type</em> of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. <code>type.__subclasses__()</code> is an example of a method on the <code>type</code> metaclass. You can also define the normal 'magic' methods, like <code>__add__</code>, <code>__iter__</code> and <code>__getattr__</code>, to implement or change how the class behaves.</p>\n\n<p>Here's an aggregated example of the bits and pieces:</p>\n\n<pre><code>def make_hook(f):\n    \"\"\"Decorator to turn 'foo' method into '__foo__'\"\"\"\n    f.is_hook = 1\n    return f\n\nclass MyType(type):\n    def __new__(mcls, name, bases, attrs):\n\n        if name.startswith('None'):\n            return None\n\n        # Go over attributes and see if they should be renamed.\n        newattrs = {}\n        for attrname, attrvalue in attrs.iteritems():\n            if getattr(attrvalue, 'is_hook', 0):\n                newattrs['__%s__' % attrname] = attrvalue\n            else:\n                newattrs[attrname] = attrvalue\n\n        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)\n\n    def __init__(self, name, bases, attrs):\n        super(MyType, self).__init__(name, bases, attrs)\n\n        # classregistry.register(self, self.interfaces)\n        print \"Would register class %s now.\" % self\n\n    def __add__(self, other):\n        class AutoClass(self, other):\n            pass\n        return AutoClass\n        # Alternatively, to autogenerate the classname as well as the class:\n        # return type(self.__name__ + other.__name__, (self, other), {})\n\n    def unregister(self):\n        # classregistry.unregister(self)\n        print \"Would unregister class %s now.\" % self\n\nclass MyObject:\n    __metaclass__ = MyType\n\n\nclass NoneSample(MyObject):\n    pass\n\n# Will print \"NoneType None\"\nprint type(NoneSample), repr(NoneSample)\n\nclass Example(MyObject):\n    def __init__(self, value):\n        self.value = value\n    @make_hook\n    def add(self, other):\n        return self.__class__(self.value + other.value)\n\n# Will unregister the class\nExample.unregister()\n\ninst = Example(10)\n# Will fail with an AttributeError\n#inst.unregister()\n\nprint inst + inst\nclass Sibling(MyObject):\n    pass\n\nExampleSibling = Example + Sibling\n# ExampleSibling is now a subclass of both Example and Sibling (with no\n# content of its own) although it will believe it's called 'AutoClass'\nprint ExampleSibling\nprint ExampleSibling.__mro__\n</code></pre>\n"
  },
  {
    "content": "How do I check whether a file exists without exceptions?",
    "chosen": "<p>If the reason you're checking is so you can do something like <code>if file_exists: open_it()</code>, it's safer to use a <code>try</code> around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</p>\n<p>If you're not planning to open the file immediately, you can use <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\"><code>os.path.isfile</code></a> if you need to be sure it's a file.</p>\n<blockquote>\n<p>Return <code>True</code> if path is an existing regular file. This follows symbolic links, so both <a href=\"https://docs.python.org/library/os.path.html#os.path.islink\" rel=\"noreferrer\">islink()</a> and <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\">isfile()</a> can be true for the same path.</p>\n</blockquote>\n<pre><code>import os.path\nos.path.isfile(fname)\n</code></pre>\n<h3><code>pathlib</code></h3>\n<p>Starting with Python 3.4, the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file\" rel=\"noreferrer\"><code>pathlib</code> module</a> offers an object-oriented approach (backported to <code>pathlib2</code> in Python 2.7):</p>\n<pre><code>from pathlib import Path\n\nmy_file = Path(&quot;/path/to/file&quot;)\nif my_file.is_file():\n    # file exists\n</code></pre>\n<p>To check a directory, do:</p>\n<pre><code>if my_file.is_dir():\n    # directory exists\n</code></pre>\n<p>To check whether a <code>Path</code> object exists independently of whether is it a file or directory, use <code>exists()</code>:</p>\n<pre><code>if my_file.exists():\n    # path exists\n</code></pre>\n<p>You can also use <code>resolve(strict=True)</code> in a <code>try</code> block:</p>\n<pre><code>try:\n    my_abs_path = my_file.resolve(strict=True)\nexcept FileNotFoundError:\n    # doesn't exist\nelse:\n    # exists\n</code></pre>\n",
    "rejected": "<pre><code>import os\n\nif os.path.isfile(filepath):\n   print(&quot;File exists&quot;)\n</code></pre>\n"
  },
  {
    "content": "How do I merge two dictionaries in a single expression in Python?",
    "chosen": "<h2>How can I merge two Python dictionaries in a single expression?</h2>\n<p>For dictionaries <code>x</code> and <code>y</code>, their shallowly-merged dictionary <code>z</code> takes values from <code>y</code>, replacing those from <code>x</code>.</p>\n<ul>\n<li><p>In Python 3.9.0 or greater (released 17 October 2020, <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"noreferrer\"><code>PEP-584</code></a>, <a href=\"https://bugs.python.org/issue36144\" rel=\"noreferrer\">discussed here</a>):</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = x | y\n</code></pre>\n</li>\n<li><p>In Python 3.5 or greater:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, **y}\n</code></pre>\n</li>\n<li><p>In Python 2, (or 3.4 or lower) write a function:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_two_dicts(x, y):\n    z = x.copy()   # start with keys and values of x\n    z.update(y)    # modifies z with keys and values of y\n    return z\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_two_dicts(x, y)\n</code></pre>\n</li>\n</ul>\n<h3>Explanation</h3>\n<p>Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:</p>\n<pre class=\"lang-py prettyprint-override\"><code>x = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\n</code></pre>\n<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged, and the second dictionary's values overwriting those from the first.</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'c': 4}\n</code></pre>\n<p>A new syntax for this, proposed in <a href=\"https://www.python.org/dev/peps/pep-0448\" rel=\"noreferrer\">PEP 448</a> and <a href=\"https://mail.python.org/pipermail/python-dev/2015-February/138564.html\" rel=\"noreferrer\">available as of Python 3.5</a>, is</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, **y}\n</code></pre>\n<p>And it is indeed a single expression.</p>\n<p>Note that we can merge in with literal notation as well:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = {**x, 'foo': 1, 'bar': 2, **y}\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}\n</code></pre>\n<p>It is now showing as implemented in the <a href=\"https://www.python.org/dev/peps/pep-0478/#features-for-3-5\" rel=\"noreferrer\">release schedule for 3.5, PEP 478</a>, and it has now made its way into the <a href=\"https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations\" rel=\"noreferrer\">What's New in Python 3.5</a> document.</p>\n<p>However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = x.copy()\nz.update(y) # which returns None since it mutates z\n</code></pre>\n<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s values, thus <code>b</code> will point to <code>3</code> in our final result.</p>\n<h2>Not yet on Python 3.5, but want a <em>single expression</em></h2>\n<p>If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a <em>single expression</em>, the most performant while the correct approach is to put it in a function:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_two_dicts(x, y):\n    &quot;&quot;&quot;Given two dictionaries, merge them into a new dict as a shallow copy.&quot;&quot;&quot;\n    z = x.copy()\n    z.update(y)\n    return z\n</code></pre>\n<p>and then you have a single expression:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_two_dicts(x, y)\n</code></pre>\n<p>You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def merge_dicts(*dict_args):\n    &quot;&quot;&quot;\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    &quot;&quot;&quot;\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n</code></pre>\n<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries <code>a</code> to <code>g</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = merge_dicts(a, b, c, d, e, f, g) \n</code></pre>\n<p>and key-value pairs in <code>g</code> will take precedence over dictionaries <code>a</code> to <code>f</code>, and so on.</p>\n<h2>Critiques of Other Answers</h2>\n<p>Don't use what you see in the formerly accepted answer:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = dict(x.items() + y.items())\n</code></pre>\n<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists -</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a.items() + b.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'\n</code></pre>\n<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and computation power.</p>\n<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a.items() | b.items())\n</code></pre>\n<p>This example demonstrates what happens when values are unhashable:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a': []}\n&gt;&gt;&gt; y = {'b': []}\n&gt;&gt;&gt; dict(x.items() | y.items())\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n</code></pre>\n<p>Here's an example where <code>y</code> should have precedence, but instead the value from <code>x</code> is retained due to the arbitrary order of sets:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a': 2}\n&gt;&gt;&gt; y = {'a': 1}\n&gt;&gt;&gt; dict(x.items() | y.items())\n{'a': 2}\n</code></pre>\n<p>Another hack you should not use:</p>\n<pre class=\"lang-py prettyprint-override\"><code>z = dict(x, **y)\n</code></pre>\n<p>This uses the <code>dict</code> constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</p>\n<p>Here's an example of the usage being <a href=\"https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff\" rel=\"noreferrer\">remediated in django</a>.</p>\n<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset</code>s or tuples), but <strong>this method fails in Python 3 when keys are not strings.</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; c = dict(a, **b)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: keyword arguments must be strings\n</code></pre>\n<p>From the <a href=\"https://mail.python.org/pipermail/python-dev/2010-April/099459.html\" rel=\"noreferrer\">mailing list</a>, Guido van Rossum, the creator of the language, wrote:</p>\n<blockquote>\n<p>I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>Apparently dict(x, **y) is going around as &quot;cool hack&quot; for &quot;call\nx.update(y) and return x&quot;. Personally, I find it more despicable than\ncool.</p>\n</blockquote>\n<p>It is my understanding (as well as the understanding of the <a href=\"https://mail.python.org/pipermail/python-dev/2010-April/099485.html\" rel=\"noreferrer\">creator of the language</a>) that the intended usage for <code>dict(**y)</code> is for creating dictionaries for readability purposes, e.g.:</p>\n<pre class=\"lang-py prettyprint-override\"><code>dict(a=1, b=10, c=11)\n</code></pre>\n<p>instead of</p>\n<pre class=\"lang-py prettyprint-override\"><code>{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n<h2>Response to comments</h2>\n<blockquote>\n<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.</p>\n</blockquote>\n<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict</code> broke this consistency in Python 2:</p>\n<pre><code>&gt;&gt;&gt; foo(**{('a', 'b'): None})\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: foo() keywords must be strings\n&gt;&gt;&gt; dict(**{('a', 'b'): None})\n{('a', 'b'): None}\n</code></pre>\n<p>This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</p>\n<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</p>\n<p>More comments:</p>\n<blockquote>\n<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python 2. Readability counts.</p>\n</blockquote>\n<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</p>\n<blockquote>\n<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word &quot;merging&quot; these answers describe &quot;updating one dict with another&quot;, and not merging.</p>\n</blockquote>\n<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em> merge of <em><strong>two</strong></em> dictionaries, with the first's values being overwritten by the second's - in a single expression.</p>\n<p>Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from copy import deepcopy\n\ndef dict_of_dicts_merge(x, y):\n    z = {}\n    overlapping_keys = x.keys() &amp; y.keys()\n    for key in overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    for key in x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    for key in y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    return z\n</code></pre>\n<p>Usage:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}\n&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}\n&gt;&gt;&gt; dict_of_dicts_merge(x, y)\n{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}\n</code></pre>\n<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href=\"https://stackoverflow.com/a/24088493/541136\">my answer to the canonical question on a &quot;Dictionaries of dictionaries merge&quot;</a>.</p>\n<h2>Less Performant But Correct Ad-hocs</h2>\n<p>These approaches are less performant, but they will provide correct behavior.\nThey will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do</em> respect the order of precedence (latter dictionaries have precedence)</p>\n<p>You can also chain the dictionaries manually inside a <a href=\"https://www.python.org/dev/peps/pep-0274/\" rel=\"noreferrer\">dict comprehension</a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\n</code></pre>\n<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</p>\n<pre class=\"lang-py prettyprint-override\"><code>dict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\n</code></pre>\n<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the correct order:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from itertools import chain\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\n</code></pre>\n<h2>Performance Analysis</h2>\n<p>I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)</p>\n<pre class=\"lang-py prettyprint-override\"><code>from timeit import repeat\nfrom itertools import chain\n\nx = dict.fromkeys('abcdefg')\ny = dict.fromkeys('efghijk')\n\ndef merge_two_dicts(x, y):\n    z = x.copy()\n    z.update(y)\n    return z\n\nmin(repeat(lambda: {**x, **y}))\nmin(repeat(lambda: merge_two_dicts(x, y)))\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n</code></pre>\n<p>In Python 3.8.1, NixOS:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))\n1.0804965235292912\n&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))\n1.636518670246005\n&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\n3.1779992282390594\n&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))\n2.740647904574871\n&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n4.266070580109954\n</code></pre>\n<pre class=\"lang-sh prettyprint-override\"><code>$ uname -a\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux\n</code></pre>\n<h2>Resources on Dictionaries</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302\">My explanation of Python's <strong>dictionary implementation</strong>, updated for 3.6.</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535\">Answer on how to add new keys to a dictionary</a></li>\n<li><a href=\"https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067\">Mapping two lists into a dictionary</a></li>\n<li><a href=\"https://docs.python.org/3/tutorial/datastructures.html#dictionaries\" rel=\"noreferrer\">The official Python docs on dictionaries</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=66P5FMkWoVU\" rel=\"noreferrer\">The Dictionary Even Mightier</a> - talk by Brandon Rhodes at Pycon 2017</li>\n<li><a href=\"https://www.youtube.com/watch?v=npw4s1QTmPg\" rel=\"noreferrer\">Modern Python Dictionaries, A Confluence of Great Ideas</a> - talk by Raymond Hettinger at Pycon 2017</li>\n</ul>\n",
    "rejected": "<p>An alternative:</p>\n\n<pre><code>z = x.copy()\nz.update(y)\n</code></pre>\n"
  },
  {
    "content": "How do I execute a program or call a system command?",
    "chosen": "<p>Use <a href=\"https://docs.python.org/library/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run</code></a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import subprocess\n\nsubprocess.run([&quot;ls&quot;, &quot;-l&quot;]) \n</code></pre>\n<p>Another common way is <a href=\"https://docs.python.org/library/os.html#os.system\" rel=\"noreferrer\"><code>os.system</code></a> but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also <code>subprocess.run</code> is generally more flexible (you can get the <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stdout\" rel=\"noreferrer\"><code>stdout</code></a>, <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stderr\" rel=\"noreferrer\"><code>stderr</code></a>, the <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.returncode\" rel=\"noreferrer\">&quot;real&quot; status code</a>, better <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CalledProcessError\" rel=\"noreferrer\">error handling</a>, etc.). Even the <a href=\"https://docs.python.org/library/os.html#os.system\" rel=\"noreferrer\">documentation for <code>os.system</code></a> recommends using <code>subprocess</code> instead.</p>\n<p>On Python 3.4 and earlier, use <code>subprocess.call</code> instead of <code>.run</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>subprocess.call([&quot;ls&quot;, &quot;-l&quot;])\n</code></pre>\n",
    "rejected": "<p>Here is a summary of ways to call external programs, including their advantages and disadvantages:</p>\n<ol>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.system\" rel=\"nofollow noreferrer\"><code>os.system</code></a> passes the command and arguments to your system's shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection. For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>os.system(&quot;some_command &lt; input_file | another_command &gt; output_file&quot;)\n</code></pre>\n<p>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.</p>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.popen\" rel=\"nofollow noreferrer\"><code>os.popen</code></a> will do the same thing as <code>os.system</code> except that it gives you a file-like object that you can use to access standard input/output for that process. There are 3 other variants of popen that all handle the i/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything. Example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>print(os.popen(&quot;ls -l&quot;).read())\n</code></pre>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.Popen\" rel=\"nofollow noreferrer\"><code>subprocess.Popen</code></a>. This is intended as a replacement for <code>os.popen</code>, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you'd say:</p>\n<pre class=\"lang-py prettyprint-override\"><code>print subprocess.Popen(&quot;echo Hello World&quot;, shell=True, stdout=subprocess.PIPE).stdout.read()\n</code></pre>\n<p>instead of</p>\n<pre class=\"lang-py prettyprint-override\"><code>print os.popen(&quot;echo Hello World&quot;).read()\n</code></pre>\n<p>but it is nice to have all of the options there in one unified class instead of 4 different popen functions. See <a href=\"https://docs.python.org/3/library/subprocess.html#popen-constructor\" rel=\"nofollow noreferrer\">the documentation</a>.</p>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.call\" rel=\"nofollow noreferrer\"><code>subprocess.call</code></a>. This is basically just like the <code>Popen</code> class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>return_code = subprocess.call(&quot;echo Hello World&quot;, shell=True)\n</code></pre>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.run\" rel=\"nofollow noreferrer\"><code>subprocess.run</code></a>. Python 3.5+ only. Similar to the above but even more flexible and returns a <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess\" rel=\"nofollow noreferrer\"><code>CompletedProcess</code></a> object when the command finishes executing.</p>\n</li>\n<li><p><code>os.fork</code>, <code>os.exec</code>, <code>os.spawn</code> are similar to their C language counterparts, but I don't recommend using them directly.</p>\n</li>\n</ol>\n<p>The <code>subprocess</code> module should probably be what you use.</p>\n<p>Finally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. <strong>There are serious security implications</strong> if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:</p>\n<pre class=\"lang-py prettyprint-override\"><code>print subprocess.Popen(&quot;echo %s &quot; % user_input, stdout=PIPE).stdout.read()\n</code></pre>\n<p>and imagine that the user enters something &quot;<code>my mama didnt love me &amp;&amp; rm -rf /</code>&quot; which could erase the whole filesystem.</p>\n"
  },
  {
    "content": "How do I create a directory, and any missing parent directories?",
    "chosen": "<p>On Python ≥ 3.5, use <a href=\"https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\"><code>pathlib.Path.mkdir</code></a>:</p>\n\n<pre><code>from pathlib import Path\nPath(\"/my/directory\").mkdir(parents=True, exist_ok=True)\n</code></pre>\n\n<p>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:</p>\n\n<p>Try <a href=\"https://docs.python.org/library/os.path.html#os.path.exists\" rel=\"noreferrer\"><code>os.path.exists</code></a>, and consider <a href=\"https://docs.python.org/library/os.html#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs</code></a> for the creation.</p>\n\n<pre><code>import os\nif not os.path.exists(directory):\n    os.makedirs(directory)\n</code></pre>\n\n<p>As noted in comments and elsewhere, there's a race condition &ndash; if the directory is created between the <code>os.path.exists</code> and the <code>os.makedirs</code> calls, the <code>os.makedirs</code> will fail with an <code>OSError</code>. Unfortunately, blanket-catching <code>OSError</code> and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</p>\n\n<p>One option would be to trap the <code>OSError</code> and examine the embedded error code (see <a href=\"https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror\">Is there a cross-platform way of getting information from Python’s OSError</a>):</p>\n\n<pre><code>import os, errno\n\ntry:\n    os.makedirs(directory)\nexcept OSError as e:\n    if e.errno != errno.EEXIST:\n        raise\n</code></pre>\n\n<p>Alternatively, there could be a second <code>os.path.exists</code>, but suppose another created the directory after the first check, then removed it before the second one &ndash; we could still be fooled. </p>\n\n<p>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</p>\n\n<p>Modern versions of Python improve this code quite a bit, both by exposing <a href=\"https://docs.python.org/3.3/library/exceptions.html?#FileExistsError\" rel=\"noreferrer\"><code>FileExistsError</code></a> (in 3.3+)...</p>\n\n<pre><code>try:\n    os.makedirs(\"path/to/directory\")\nexcept FileExistsError:\n    # directory already exists\n    pass\n</code></pre>\n\n<p>...and by allowing <a href=\"https://docs.python.org/3.2/library/os.html#os.makedirs\" rel=\"noreferrer\">a keyword argument to <code>os.makedirs</code> called <code>exist_ok</code></a> (in 3.2+).</p>\n\n<pre><code>os.makedirs(\"path/to/directory\", exist_ok=True)  # succeeds even if directory exists.\n</code></pre>\n",
    "rejected": "<p>Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:</p>\n\n<pre><code>import os\nimport errno\n\ndef make_sure_path_exists(path):\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            raise\n</code></pre>\n\n<p>In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an <code>OSError</code> raised with <code>errno.EACCES</code> (Permission denied, error 13).</p>\n"
  },
  {
    "content": "How can I access the index value in a &#39;for&#39; loop?",
    "chosen": "<p>Use the built-in function <a href=\"https://docs.python.org/3/library/functions.html#enumerate\" rel=\"noreferrer\" title=\"enumerate\"><code>enumerate()</code></a>:</p>\n<pre><code>for idx, x in enumerate(xs):\n    print(idx, x)\n</code></pre>\n<p>It is <em><a href=\"https://stackoverflow.com/questions/25011078/what-does-pythonic-mean\">non-Pythonic</a></em> to manually index via <code>for i in range(len(xs)): x = xs[i]</code> or manually manage an additional state variable.</p>\n<p>Check out <a href=\"https://www.python.org/dev/peps/pep-0279/\" rel=\"noreferrer\" title=\"PEP 279\">PEP 279</a> for more.</p>\n",
    "rejected": "<blockquote>\n<p>Using a for loop, how do I access the loop index, from 1 to 5 in this case?</p>\n</blockquote>\n<p>Use <code>enumerate</code> to get the index with the element as you iterate:</p>\n<pre><code>for index, item in enumerate(items):\n    print(index, item)\n</code></pre>\n<p>And note that Python's indexes start at zero, so you would get 0 to 4 with the above. If you want the count, 1 to 5, do this:</p>\n<pre><code>count = 0 # in case items is empty and you need it after the loop\nfor count, item in enumerate(items, start=1):\n    print(count, item)\n</code></pre>\n<h1>Unidiomatic control flow</h1>\n<p>What you are asking for is the Pythonic equivalent of the following, which is the algorithm most programmers of lower-level languages would use:</p>\n<blockquote>\n<pre><code>index = 0            # Python's indexing starts at zero\nfor item in items:   # Python's for loops are a &quot;for each&quot; loop \n    print(index, item)\n    index += 1\n</code></pre>\n</blockquote>\n<p>Or in languages that do not have a for-each loop:</p>\n<blockquote>\n<pre><code>index = 0\nwhile index &lt; len(items):\n    print(index, items[index])\n    index += 1\n</code></pre>\n</blockquote>\n<p>or sometimes more commonly (but unidiomatically) found in Python:</p>\n<blockquote>\n<pre><code>for index in range(len(items)):\n    print(index, items[index])\n</code></pre>\n</blockquote>\n<h1>Use the Enumerate Function</h1>\n<p>Python's <a href=\"https://docs.python.org/2/library/functions.html#enumerate\" rel=\"noreferrer\"><code>enumerate</code> function</a> reduces the visual clutter by hiding the accounting for the indexes, and encapsulating the iterable into another iterable (an <code>enumerate</code> object) that yields a two-item tuple of the index and the item that the original iterable would provide. That looks like this:</p>\n<pre><code>for index, item in enumerate(items, start=0):   # default is zero\n    print(index, item)\n</code></pre>\n<p>This code sample is fairly well the <a href=\"http://python.net/%7Egoodger/projects/pycon/2007/idiomatic/handout.html#index-item-2-enumerate\" rel=\"noreferrer\">canonical</a> example of the difference between code that is idiomatic of Python and code that is not. Idiomatic code is sophisticated (but not complicated) Python, written in the way that it was intended to be used. Idiomatic code is expected by the designers of the language, which means that usually this code is not just more readable, but also more efficient.</p>\n<h2>Getting a count</h2>\n<p>Even if you don't need indexes as you go, but you need a count of the iterations (sometimes desirable) you can start with <code>1</code> and the final number will be your count.</p>\n<pre><code>count = 0 # in case items is empty\nfor count, item in enumerate(items, start=1):   # default is zero\n    print(item)\n\nprint('there were {0} items printed'.format(count))\n</code></pre>\n<p>The count seems to be more what you intend to ask for (as opposed to index) when you said you wanted from 1 to 5.</p>\n<hr />\n<h2>Breaking it down - a step by step explanation</h2>\n<p>To break these examples down, say we have a list of items that we want to iterate over with an index:</p>\n<pre><code>items = ['a', 'b', 'c', 'd', 'e']\n</code></pre>\n<p>Now we pass this iterable to enumerate, creating an enumerate object:</p>\n<pre><code>enumerate_object = enumerate(items) # the enumerate object\n</code></pre>\n<p>We can pull the first item out of this iterable that we would get in a loop with the <code>next</code> function:</p>\n<pre><code>iteration = next(enumerate_object) # first iteration from enumerate\nprint(iteration)\n</code></pre>\n<p>And we see we get a tuple of <code>0</code>, the first index, and <code>'a'</code>, the first item:</p>\n<pre><code>(0, 'a')\n</code></pre>\n<p>we can use what is referred to as &quot;<a href=\"https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences\" rel=\"noreferrer\">sequence unpacking</a>&quot; to extract the elements from this two-tuple:</p>\n<pre><code>index, item = iteration\n#   0,  'a' = (0, 'a') # essentially this.\n</code></pre>\n<p>and when we inspect <code>index</code>, we find it refers to the first index, 0, and <code>item</code> refers to the first item, <code>'a'</code>.</p>\n<pre><code>&gt;&gt;&gt; print(index)\n0\n&gt;&gt;&gt; print(item)\na\n</code></pre>\n<h1>Conclusion</h1>\n<ul>\n<li>Python indexes start at zero</li>\n<li>To get these indexes from an iterable as you iterate over it, use the enumerate function</li>\n<li>Using enumerate in the idiomatic way (along with tuple unpacking) creates code that is more readable and maintainable:</li>\n</ul>\n<p>So do this:</p>\n<pre><code>for index, item in enumerate(items, start=0):   # Python indexes start at zero\n    print(index, item)\n</code></pre>\n"
  },
  {
    "content": "How do I make a flat list out of a list of lists?",
    "chosen": "<p>A list of lists named <code>xss</code> can be flattened using a nested <a href=\"https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions\" rel=\"noreferrer\">list comprehension</a>:</p>\n<pre><code>flat_list = [\n    x\n    for xs in xss\n    for x in xs\n]\n</code></pre>\n<p>The above is equivalent to:</p>\n<pre><code>flat_list = []\n\nfor xs in xss:\n    for x in xs:\n        flat_list.append(x)\n</code></pre>\n<p>Here is the corresponding function:</p>\n<pre><code>def flatten(xss):\n    return [x for xs in xss for x in xs]\n</code></pre>\n<p>This is the fastest method.\nAs evidence, using the <a href=\"https://docs.python.org/3/library/timeit.html\" rel=\"noreferrer\"><code>timeit</code></a> module in the standard library, we see:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]'\n10000 loops, best of 3: 143 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])'\n1000 loops, best of 3: 969 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)'\n1000 loops, best of 3: 1.1 msec per loop\n</code></pre>\n<p>Explanation: the methods based on <code>+</code> (including the implied use in <code>sum</code>) are, of necessity, <code>O(L**2)</code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth <code>L-1</code> times, the second M items <code>L-2</code> times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., <code>M * (L**2)/2</code>.</p>\n<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</p>\n",
    "rejected": "<p>I tested most suggested solutions with <a href=\"https://github.com/nschloe/perfplot\" rel=\"noreferrer\">perfplot</a> (a pet project of mine, essentially a wrapper around <code>timeit</code>), and found</p>\n<pre class=\"lang-py prettyprint-override\"><code>import functools\nimport operator\nfunctools.reduce(operator.iconcat, a, [])\n</code></pre>\n<p>to be the fastest solution, both when many small lists and few long lists are concatenated. (<code>operator.iadd</code> is equally fast.)</p>\n<p>A simpler and also acceptable variant is</p>\n<pre class=\"lang-py prettyprint-override\"><code>out = []\nfor sublist in a:\n    out.extend(sublist)\n</code></pre>\n<p>If the number of sublists is large, this performs a little worse than the above suggestion.</p>\n<p><a href=\"https://i.sstatic.net/82YEG.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/82YEG.png\" alt=\"enter image description here\" /></a></p>\n<p><a href=\"https://i.sstatic.net/Mo7iy.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/Mo7iy.png\" alt=\"enter image description here\" /></a></p>\n<hr />\n<p>Code to reproduce the plot:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import functools\nimport itertools\nimport operator\n\nimport numpy as np\nimport perfplot\n\n\ndef forfor(a):\n    return [item for sublist in a for item in sublist]\n\n\ndef sum_brackets(a):\n    return sum(a, [])\n\n\ndef functools_reduce(a):\n    return functools.reduce(operator.concat, a)\n\n\ndef functools_reduce_iconcat(a):\n    return functools.reduce(operator.iconcat, a, [])\n\n\ndef itertools_chain(a):\n    return list(itertools.chain.from_iterable(a))\n\n\ndef numpy_flat(a):\n    return list(np.array(a).flat)\n\n\ndef numpy_concatenate(a):\n    return list(np.concatenate(a))\n\n\ndef extend(a):\n    out = []\n    for sublist in a:\n        out.extend(sublist)\n    return out\n\n\nb = perfplot.bench(\n    setup=lambda n: [list(range(10))] * n,\n    # setup=lambda n: [list(range(n))] * 10,\n    kernels=[\n        forfor,\n        sum_brackets,\n        functools_reduce,\n        functools_reduce_iconcat,\n        itertools_chain,\n        numpy_flat,\n        numpy_concatenate,\n        extend,\n    ],\n    n_range=[2 ** k for k in range(16)],\n    xlabel=&quot;num lists (of length 10)&quot;,\n    # xlabel=&quot;len lists (10 lists total)&quot;\n)\nb.save(&quot;out.png&quot;)\nb.show()\n</code></pre>\n"
  },
  {
    "content": "What is the difference between @staticmethod and @classmethod in Python?",
    "chosen": "<p>Maybe a bit of example code will help: Notice the difference in the call signatures of <code>foo</code>, <code>class_foo</code> and <code>static_foo</code>:</p>\n<pre><code>class A(object):\n    def foo(self, x):\n        print(f&quot;executing foo({self}, {x})&quot;)\n\n    @classmethod\n    def class_foo(cls, x):\n        print(f&quot;executing class_foo({cls}, {x})&quot;)\n\n    @staticmethod\n    def static_foo(x):\n        print(f&quot;executing static_foo({x})&quot;)\n\na = A()\n</code></pre>\n<p>Below is the usual way an object instance calls a method. The object instance, <code>a</code>, is implicitly passed as the first argument.</p>\n<pre><code>a.foo(1)\n# executing foo(&lt;__main__.A object at 0xb7dbef0c&gt;, 1)\n</code></pre>\n<hr />\n<p><strong>With classmethods</strong>, the class of the object instance is implicitly passed as the first argument instead of <code>self</code>.</p>\n<pre><code>a.class_foo(1)\n# executing class_foo(&lt;class '__main__.A'&gt;, 1)\n</code></pre>\n<p>You can also call <code>class_foo</code> using the class. In fact, if you define something to be\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. <code>A.foo(1)</code> would have raised a TypeError, but <code>A.class_foo(1)</code> works just fine:</p>\n<pre><code>A.class_foo(1)\n# executing class_foo(&lt;class '__main__.A'&gt;, 1)\n</code></pre>\n<p>One use people have found for class methods is to create <a href=\"https://stackoverflow.com/a/1950927/190597\">inheritable alternative constructors</a>.</p>\n<hr />\n<p><strong>With staticmethods</strong>, neither <code>self</code> (the object instance) nor  <code>cls</code> (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:</p>\n<pre><code>a.static_foo(1)\n# executing static_foo(1)\n\nA.static_foo('hi')\n# executing static_foo(hi)\n</code></pre>\n<p>Staticmethods are used to group functions which have some logical connection with a class to the class.</p>\n<hr />\n<p><code>foo</code> is just a function, but when you call <code>a.foo</code> you don't just get the function,\nyou get a &quot;partially applied&quot; version of the function with the object instance <code>a</code> bound as the first argument to the function. <code>foo</code> expects 2 arguments, while <code>a.foo</code> only expects 1 argument.</p>\n<p><code>a</code> is bound to <code>foo</code>. That is what is meant by the term &quot;bound&quot; below:</p>\n<pre><code>print(a.foo)\n# &lt;bound method A.foo of &lt;__main__.A object at 0xb7d52f0c&gt;&gt;\n</code></pre>\n<p>With <code>a.class_foo</code>, <code>a</code> is not bound to <code>class_foo</code>, rather the class <code>A</code> is bound to <code>class_foo</code>.</p>\n<pre><code>print(a.class_foo)\n# &lt;bound method type.class_foo of &lt;class '__main__.A'&gt;&gt;\n</code></pre>\n<p>Here, with a staticmethod, even though it is a method, <code>a.static_foo</code> just returns\na good 'ole function with no arguments bound. <code>static_foo</code> expects 1 argument, and\n<code>a.static_foo</code> expects 1 argument too.</p>\n<pre><code>print(a.static_foo)\n# &lt;function static_foo at 0xb7d479cc&gt;\n</code></pre>\n<p>And of course the same thing happens when you call <code>static_foo</code> with the class <code>A</code> instead.</p>\n<pre><code>print(A.static_foo)\n# &lt;function static_foo at 0xb7d479cc&gt;\n</code></pre>\n",
    "rejected": "<p>A <strong>staticmethod</strong> is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument.</p>\n<p>A <strong>classmethod</strong>, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how <code>dict.fromkeys()</code>, a classmethod, returns an instance of the subclass when called on a subclass:</p>\n<pre><code>&gt;&gt;&gt; class DictSubclass(dict):\n...     def __repr__(self):\n...         return &quot;DictSubclass&quot;\n... \n&gt;&gt;&gt; dict.fromkeys(&quot;abc&quot;)\n{'a': None, 'c': None, 'b': None}\n&gt;&gt;&gt; DictSubclass.fromkeys(&quot;abc&quot;)\nDictSubclass\n&gt;&gt;&gt; \n</code></pre>\n"
  },
  {
    "content": "How slicing in Python works",
    "chosen": "<p>The syntax is:</p>\n<pre><code>a[start:stop]  # items start through stop-1\na[start:]      # items start through the rest of the array\na[:stop]       # items from the beginning through stop-1\na[:]           # a copy of the whole array\n</code></pre>\n<p>There is also the <code>step</code> value, which can be used with any of the above:</p>\n<pre><code>a[start:stop:step] # start through not past stop, by step\n</code></pre>\n<p>The key point to remember is that the <code>:stop</code> value represents the first value that is <em>not</em> in the selected slice. So, the difference between <code>stop</code> and <code>start</code> is the number of elements selected (if <code>step</code> is 1, the default).</p>\n<p>The other feature is that <code>start</code> or <code>stop</code> may be a <em>negative</em> number, which means it counts from the end of the array instead of the beginning. So:</p>\n<pre><code>a[-1]    # last item in the array\na[-2:]   # last two items in the array\na[:-2]   # everything except the last two items\n</code></pre>\n<p>Similarly, <code>step</code> may be a negative number:</p>\n<pre><code>a[::-1]    # all items in the array, reversed\na[1::-1]   # the first two items, reversed\na[:-3:-1]  # the last two items, reversed\na[-3::-1]  # everything except the last two items, reversed\n</code></pre>\n<p>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for <code>a[:-2]</code> and <code>a</code> only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</p>\n<h3>Relationship with the <code>slice</code> object</h3>\n<p>A <a href=\"https://docs.python.org/3/library/functions.html#slice\" rel=\"noreferrer\"><code>slice</code> object</a> can represent a slicing operation, i.e.:</p>\n<pre><code>a[start:stop:step]\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>a[slice(start, stop, step)]\n</code></pre>\n<p>Slice objects also behave slightly differently depending on the number of arguments, similar to <code>range()</code>, i.e. both <code>slice(stop)</code> and <code>slice(start, stop[, step])</code> are supported.\nTo skip specifying a given argument, one might use <code>None</code>, so that e.g. <code>a[start:]</code> is equivalent to <code>a[slice(start, None)]</code> or <code>a[::-1]</code> is equivalent to <code>a[slice(None, None, -1)]</code>.</p>\n<p>While the <code>:</code>-based notation is very helpful for simple slicing, the explicit use of <code>slice()</code> objects simplifies the programmatic generation of slicing.</p>\n",
    "rejected": "<blockquote>\n<h2>Explain Python's slice notation</h2>\n</blockquote>\n<p>In short, the colons (<code>:</code>) in subscript notation (<code>subscriptable[subscriptarg]</code>) make slice notation, which has the optional arguments <code>start</code>, <code>stop</code>, and <code>step</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>sliceable[start:stop:step]\n</code></pre>\n<p>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</p>\n<h2>Important Definitions</h2>\n<p>To begin with, let's define a few terms:</p>\n<blockquote>\n<p><strong><code>start</code>:</strong> the beginning index of the slice, it will include the element at this index unless it is the same as <em>stop</em>, defaults to 0, i.e. the first index. If it's negative, it means to start <code>n</code> items from the end.</p>\n<p><strong><code>stop</code>:</strong> the ending index of the slice, it does <em>not</em> include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</p>\n<p><strong><code>step</code>:</strong> the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</p>\n</blockquote>\n<h2>How Indexing Works</h2>\n<p>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the <em>start</em> and <em>stop</em>, and for the <em>step</em>, you simply decrement your index. This example is <a href=\"https://docs.python.org/2/tutorial/introduction.html\" rel=\"noreferrer\">from the documentation's tutorial</a>, but I've modified it slightly to indicate which item in a sequence each index references:</p>\n<pre class=\"lang-py prettyprint-override\"><code> +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n   0   1   2   3   4   5 \n  -6  -5  -4  -3  -2  -1\n</code></pre>\n<h2>How Slicing Works</h2>\n<p>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually <a href=\"https://docs.python.org/2/reference/datamodel.html#object.__getitem__\" rel=\"noreferrer\">implement the <code>__getitem__</code> method of the sequence, according to the Python data model</a>.)</p>\n<p>Slice notation works like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>sequence[start:stop:step]\n</code></pre>\n<p>And recall that there are defaults for <em>start</em>, <em>stop</em>, and <em>step</em>, so to access the defaults, simply leave out the argument.</p>\n<p>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_list[-9:]\n</code></pre>\n<p>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</p>\n<h2>Explanation:</h2>\n<p>The full notation is</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_list[-9:None:None]\n</code></pre>\n<p>and to substitute the defaults (actually when <code>step</code> is negative, <code>stop</code>'s default is <code>-len(my_list) - 1</code>, so <code>None</code> for stop really just means it goes to whichever end step takes it to):</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_list[-9:len(my_list):1]\n</code></pre>\n<p>The <strong>colon</strong>, <code>:</code>,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</p>\n<pre class=\"lang-py prettyprint-override\"><code>list_copy = sequence[:]\n</code></pre>\n<p>And clearing them is with:</p>\n<pre class=\"lang-py prettyprint-override\"><code>del my_list[:]\n</code></pre>\n<p>(Python 3 gets a <code>list.copy</code> and <code>list.clear</code> method.)</p>\n<h3>When <code>step</code> is negative, the defaults for <code>start</code> and <code>stop</code> change</h3>\n<p>By default, when the <code>step</code> argument is empty (or <code>None</code>), it is assigned to <code>+1</code>.</p>\n<p>But you can pass in a negative integer, and the list (or most other standard sliceables) will be sliced from the end to the beginning.</p>\n<p>Thus a negative slice will change the defaults for <code>start</code> and <code>stop</code>!</p>\n<h3>Confirming this in the source</h3>\n<p>I like to encourage users to read the source as well as the documentation. The <a href=\"https://github.com/python/cpython/blob/master/Objects/sliceobject.c\" rel=\"noreferrer\">source code for slice objects and this logic is found here</a>. First we determine if <code>step</code> is negative:</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code>step_is_negative = step_sign &lt; 0;\n</code></pre>\n</blockquote>\n<p>If so, the lower bound is <code>-1</code>  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this <code>-1</code> is <em>different</em> from a <code>-1</code> that users may pass indexes in Python indicating the last item.)</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code>if (step_is_negative) {\n    lower = PyLong_FromLong(-1L);\n    if (lower == NULL)\n        goto error;\n\n    upper = PyNumber_Add(length, lower);\n    if (upper == NULL)\n        goto error;\n}\n</code></pre>\n</blockquote>\n<p>Otherwise <code>step</code> is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code>else {\n    lower = _PyLong_Zero;\n    Py_INCREF(lower);\n    upper = length;\n    Py_INCREF(upper);\n}\n</code></pre>\n</blockquote>\n<p>Then, we may need to apply the defaults for <code>start</code> and <code>stop</code>—the default then for <code>start</code> is calculated as the upper bound when <code>step</code> is negative:</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code>if (self-&gt;start == Py_None) {\n    start = step_is_negative ? upper : lower;\n    Py_INCREF(start);\n}\n</code></pre>\n</blockquote>\n<p>and <code>stop</code>, the lower bound:</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code>if (self-&gt;stop == Py_None) {\n    stop = step_is_negative ? lower : upper;\n    Py_INCREF(stop);\n}\n</code></pre>\n</blockquote>\n<h1>Give your slices a descriptive name!</h1>\n<p>You may find it useful to separate forming the slice from passing it to the <code>list.__getitem__</code> method (<a href=\"https://docs.python.org/2/reference/datamodel.html#object.__getitem__\" rel=\"noreferrer\">that's what the square brackets do</a>). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</p>\n<p>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</p>\n<pre class=\"lang-py prettyprint-override\"><code>last_nine_slice = slice(-9, None)\n</code></pre>\n<p>The second argument, <code>None</code>, is required, so that the first argument is interpreted as the <code>start</code> argument <a href=\"https://docs.python.org/2/library/functions.html#slice\" rel=\"noreferrer\">otherwise it would be the <code>stop</code> argument</a>.</p>\n<p>You can then pass the slice object to your sequence:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; list(range(100))[last_nine_slice]\n[91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code></pre>\n<p>It's interesting that ranges also take slices:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; range(100)[last_nine_slice]\nrange(91, 100)\n</code></pre>\n<h1>Memory Considerations:</h1>\n<p>Since slices of Python lists create new objects in memory, another important function to be aware of is <code>itertools.islice</code>. Typically you'll want to iterate over a slice, not just have it created statically in memory. <code>islice</code> is perfect for this. A caveat, it doesn't support negative arguments to <code>start</code>, <code>stop</code>, or <code>step</code>, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</p>\n<pre class=\"lang-py prettyprint-override\"><code>length = 100\nlast_nine_iter = itertools.islice(list(range(length)), length-9, None, 1)\nlist_last_nine = list(last_nine_iter)\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; list_last_nine\n[91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code></pre>\n<p>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</p>\n"
  },
  {
    "content": "How can I find the index for a given item in a list?",
    "chosen": "<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)\n1\n</code></pre>\n<p>See <a href=\"https://docs.python.org/tutorial/datastructures.html#more-on-lists\" rel=\"noreferrer\">the documentation</a> for the built-in <code>.index()</code> method of the list:</p>\n<blockquote>\n<pre><code>list.index(x[, start[, end]])\n</code></pre>\n<p>Return zero-based index in the list of the first item whose value is equal to <em>x</em>. Raises a <a href=\"https://docs.python.org/library/exceptions.html#ValueError\" rel=\"noreferrer\"><code>ValueError</code></a> if there is no such item.</p>\n<p>The optional arguments <em>start</em> and <em>end</em> are interpreted as in the <a href=\"https://docs.python.org/tutorial/introduction.html#lists\" rel=\"noreferrer\">slice notation</a> and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.</p>\n</blockquote>\n<h2>Caveats</h2>\n<h3>Linear time-complexity in list length</h3>\n<p>An <code>index</code> call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code.</p>\n<p>This problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the <code>start</code> and <code>end</code> parameters can be used to narrow the search.</p>\n<p>For example:</p>\n<pre><code>&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000)\n9.356267921015387\n&gt;&gt;&gt; timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000)\n0.0004404920036904514\n</code></pre>\n<p>The second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million.</p>\n<h3>Only the index of the <em>first match</em> is returned</h3>\n<p>A call to <code>index</code> searches through the list in order until it finds a match, and <em>stops there.</em> If there could be more than one occurrence of the value, and all indices are needed, <code>index</code> cannot solve the problem:</p>\n<pre><code>&gt;&gt;&gt; [1, 1].index(1) # the `1` index is not found.\n0\n</code></pre>\n<p>Instead, use a <a href=\"/questions/34835951/\">list comprehension or generator expression to do the search</a>, with <a href=\"/questions/522563/\"><code>enumerate</code> to get indices</a>:</p>\n<pre><code>&gt;&gt;&gt; # A list comprehension gives a list of indices directly:\n&gt;&gt;&gt; [i for i, e in enumerate([1, 2, 1]) if e == 1]\n[0, 2]\n&gt;&gt;&gt; # A generator comprehension gives us an iterable object...\n&gt;&gt;&gt; g = (i for i, e in enumerate([1, 2, 1]) if e == 1)\n&gt;&gt;&gt; # which can be used in a `for` loop, or manually iterated with `next`:\n&gt;&gt;&gt; next(g)\n0\n&gt;&gt;&gt; next(g)\n2\n</code></pre>\n<p>The list comprehension and generator expression techniques still work if there is only one match, and are more generalizable.</p>\n<h3>Raises an exception if there is no match</h3>\n<p>As noted in the documentation above, using <code>.index</code> will raise an exception if the searched-for value is not in the list:</p>\n<pre><code>&gt;&gt;&gt; [1, 1].index(2)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nValueError: 2 is not in list\n</code></pre>\n<p>If this is a concern, either <a href=\"https://stackoverflow.com/questions/12934190\">explicitly check first</a> using <code>item in my_list</code>, or handle the exception with <code>try</code>/<code>except</code> as appropriate.</p>\n<p>The explicit check is simple and readable, but it must iterate the list a second time. See <a href=\"https://stackoverflow.com/questions/11360858\">What is the EAFP principle in Python?</a> for more guidance on this choice.</p>\n",
    "rejected": "<p>The majority of answers explain how to find <strong>a single index</strong>, but their methods do not return multiple indexes if the item is in the list multiple times. Use <a href=\"https://docs.python.org/library/functions.html#enumerate\" rel=\"noreferrer\"><code>enumerate()</code></a>:</p>\n\n<pre><code>for i, j in enumerate(['foo', 'bar', 'baz']):\n    if j == 'bar':\n        print(i)\n</code></pre>\n\n<p>The <code>index()</code> function only returns the first occurrence, while <code>enumerate()</code> returns all occurrences.</p>\n\n<p>As a list comprehension:</p>\n\n<pre><code>[i for i, j in enumerate(['foo', 'bar', 'baz']) if j == 'bar']\n</code></pre>\n\n<hr>\n\n<p>Here's also another small solution with <a href=\"http://docs.python.org/library/itertools.html#itertools.count\" rel=\"noreferrer\"><code>itertools.count()</code></a> (which is pretty much the same approach as enumerate):</p>\n\n<pre><code>from itertools import izip as zip, count # izip for maximum efficiency\n[i for i, j in zip(count(), ['foo', 'bar', 'baz']) if j == 'bar']\n</code></pre>\n\n<p>This is more efficient for larger lists than using <code>enumerate()</code>:</p>\n\n<pre><code>$ python -m timeit -s \"from itertools import izip as zip, count\" \"[i for i, j in zip(count(), ['foo', 'bar', 'baz']*500) if j == 'bar']\"\n10000 loops, best of 3: 174 usec per loop\n$ python -m timeit \"[i for i, j in enumerate(['foo', 'bar', 'baz']*500) if j == 'bar']\"\n10000 loops, best of 3: 196 usec per loop\n</code></pre>\n"
  },
  {
    "content": "Iterating over a dictionary using a &#39;for&#39; loop, getting keys",
    "chosen": "<p><code>key</code> is just a variable name.  </p>\n\n<pre><code>for key in d:\n</code></pre>\n\n<p>will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:</p>\n\n<p>For Python 3.x:</p>\n\n<pre><code>for key, value in d.items():\n</code></pre>\n\n<p>For Python 2.x:</p>\n\n<pre><code>for key, value in d.iteritems():\n</code></pre>\n\n<p>To test for yourself, change the word <code>key</code> to <code>poop</code>.</p>\n\n<p>In Python 3.x, <code>iteritems()</code> was replaced with simply <code>items()</code>, which returns a set-like view backed by the dict, like <code>iteritems()</code> but even better. \nThis is also available in 2.7 as <code>viewitems()</code>. </p>\n\n<p>The operation <code>items()</code> will work for both 2 and 3, but in 2 it will return a list of the dictionary's <code>(key, value)</code> pairs, which will not reflect changes to the dict that happen after the <code>items()</code> call. If you want the 2.x behavior in 3.x, you can call <code>list(d.items())</code>.</p>\n",
    "rejected": "<p>It's not that key is a special word, but that dictionaries implement the iterator protocol.  You could do this in your class, e.g. see <a href=\"https://stackoverflow.com/questions/19151/build-a-basic-python-iterator/24377#24377\">this question</a> for how to build class iterators.</p>\n\n<p>In the case of dictionaries, it's implemented at the C level.  The details are available in <a href=\"http://www.python.org/dev/peps/pep-0234/\" rel=\"noreferrer\">PEP 234</a>.  In particular, the section titled \"Dictionary Iterators\":</p>\n\n<blockquote>\n  <ul>\n  <li><p>Dictionaries implement a tp_iter slot that returns an efficient\n  iterator that iterates over the keys of the dictionary. [...] This \n  means that we can write</p>\n\n<pre><code>for k in dict: ...\n</code></pre>\n  \n  <p>which is equivalent to, but much faster than</p>\n\n<pre><code>for k in dict.keys(): ...\n</code></pre>\n  \n  <p>as long as the restriction on modifications to the dictionary\n  (either by the loop or by another thread) are not violated.</p></li>\n  <li><p>Add methods to dictionaries that return different kinds of\n  iterators explicitly:</p>\n\n<pre><code>for key in dict.iterkeys(): ...\n\nfor value in dict.itervalues(): ...\n\nfor key, value in dict.iteritems(): ...\n</code></pre>\n  \n  <p>This means that <code>for x in dict</code> is shorthand for <code>for x in\n   dict.iterkeys()</code>.</p></li>\n  </ul>\n</blockquote>\n\n<p>In Python 3, <code>dict.iterkeys()</code>, <code>dict.itervalues()</code> and <code>dict.iteritems()</code> are no longer supported. Use <code>dict.keys()</code>, <code>dict.values()</code> and <code>dict.items()</code> instead.</p>\n"
  },
  {
    "content": "How can I iterate over rows in a Pandas DataFrame?",
    "chosen": "<p><a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows\" rel=\"noreferrer\"><code>DataFrame.iterrows</code></a> is a generator which yields both the index and row (as a Series):</p>\n<pre><code>import pandas as pd\n\ndf = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})\ndf = df.reset_index()  # make sure indexes pair with number of rows\n\nfor index, row in df.iterrows():\n    print(row['c1'], row['c2'])\n</code></pre>\n\n<pre><code>10 100\n11 110\n12 120\n</code></pre>\n<hr />\n<p>Obligatory disclaimer from the <a href=\"https://pandas.pydata.org/docs/user_guide/basics.html#iteration\" rel=\"noreferrer\">documentation</a></p>\n<blockquote>\n<p>Iterating through pandas objects is generally <strong>slow</strong>. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:</p>\n<ul>\n<li>Look for a <em>vectorized</em> solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, …</li>\n<li>When you have a function that cannot work on the full DataFrame/Series at once, it is better to use <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply\" rel=\"noreferrer\" title=\"pandas.DataFrame.apply\"><code>apply()</code></a> instead of iterating over the values. See the docs on <a href=\"https://pandas.pydata.org/docs/user_guide/basics.html#basics-apply\" rel=\"noreferrer\">function application</a>.</li>\n<li>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the <a href=\"https://pandas.pydata.org/docs/user_guide/enhancingperf.html#enhancingperf\" rel=\"noreferrer\">enhancing performance</a> section for some examples of this approach.</li>\n</ul>\n</blockquote>\n<p>Other answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more.</p>\n",
    "rejected": "<p>First consider if you really need to <em>iterate</em> over rows in a DataFrame. See <a href=\"https://stackoverflow.com/a/55557758/3844376\">cs95's answer</a> for alternatives.</p>\n<p>If you still need to iterate over rows, you can use methods below. Note some  <strong>important caveats</strong> which are not mentioned in any of the other answers.</p>\n<ul>\n<li><p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\" rel=\"noreferrer\">DataFrame.iterrows()</a></p>\n<pre><code>for index, row in df.iterrows():\n    print(row[&quot;c1&quot;], row[&quot;c2&quot;])\n</code></pre>\n</li>\n<li><p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html\" rel=\"noreferrer\">DataFrame.itertuples()</a></p>\n<pre><code>for row in df.itertuples(index=True, name='Pandas'):\n    print(row.c1, row.c2)\n</code></pre>\n</li>\n</ul>\n<p><code>itertuples()</code> is supposed to be faster than <code>iterrows()</code></p>\n<p>But be aware, according to the docs (pandas 0.24.2 at the moment):</p>\n<ul>\n<li>iterrows: <code>dtype</code> might not match from row to row\n<blockquote>\n<p>Because iterrows returns a Series for each row, it <strong>does not preserve</strong> dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>iterrows: Do not modify rows</p>\n<blockquote>\n<p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.</p>\n</blockquote>\n<p>Use <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html\" rel=\"noreferrer\">DataFrame.apply()</a> instead:</p>\n<pre><code>new_df = df.apply(lambda x: x * 2, axis=1)\n</code></pre>\n</li>\n<li><p>itertuples:</p>\n<blockquote>\n<p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p>\n</blockquote>\n</li>\n</ul>\n<p>See <a href=\"https://pandas.pydata.org/docs/user_guide/basics.html#iteration\" rel=\"noreferrer\">pandas docs on iteration</a> for more details.</p>\n"
  },
  {
    "content": "How can I use a global variable in a function?",
    "chosen": "<p>You can use a global variable within other functions by declaring it as <code>global</code> <strong>within each function that assigns a value to it</strong>:</p>\n<pre><code>globvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print(globvar)     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n</code></pre>\n<p>Since it's unclear whether <code>globvar = 1</code> is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the <code>global</code> keyword.</p>\n<p>See other answers if you want to share a global variable across modules.</p>\n",
    "rejected": "<p>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</p>\n<p>Say you've got a module like this:</p>\n<pre><code># sample.py\n_my_global = 5\n\ndef func1():\n    _my_global = 42\n\ndef func2():\n    print _my_global\n\nfunc1()\nfunc2()\n</code></pre>\n<p>You might be expecting this to print 42, but instead, it prints 5.  As has already been mentioned, if you add a '<code>global</code>' declaration to <code>func1()</code>, then <code>func2()</code> will print 42.</p>\n<pre><code>def func1():\n    global _my_global \n    _my_global = 42\n</code></pre>\n<p>What's going on here is that Python assumes that any name that is <em>assigned to</em>, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only <em>reading</em> from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</p>\n<p>When you assign 42 to the name <code>_my_global</code>, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is <a href=\"http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection\" rel=\"noreferrer\">garbage-collected</a> when <code>func1()</code> returns; meanwhile, <code>func2()</code> can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of <code>_my_global</code> inside <code>func1()</code> before you assign to it, you'd get an <code>UnboundLocalError</code>, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '<code>global</code>' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</p>\n<p>(I believe that this behavior originated largely through optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</p>\n"
  },
  {
    "content": "How do I get the current time in Python?",
    "chosen": "<p>Use <a href=\"https://docs.python.org/3/library/datetime.html\" rel=\"noreferrer\"><code>datetime</code></a>:</p>\n<pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; now = datetime.datetime.now()\n&gt;&gt;&gt; now\ndatetime.datetime(2009, 1, 6, 15, 8, 24, 78915)\n&gt;&gt;&gt; print(now)\n2009-01-06 15:08:24.789150\n</code></pre>\n<p>For just the clock time without the date:</p>\n<pre><code>&gt;&gt;&gt; now.time()\ndatetime.time(15, 8, 24, 78915)\n&gt;&gt;&gt; print(now.time())\n15:08:24.789150\n</code></pre>\n<hr />\n<p>To save typing, you can import the <code>datetime</code> object from the <a href=\"https://docs.python.org/3/library/datetime.html\" rel=\"noreferrer\"><code>datetime</code></a> module:</p>\n<pre><code>&gt;&gt;&gt; from datetime import datetime\n</code></pre>\n<p>Then remove the prefix <code>datetime.</code> from all of the above.</p>\n",
    "rejected": "<p>Similar to <a href=\"https://stackoverflow.com/questions/415511/how-to-get-current-time-in-python/415519#415519\">Harley's answer</a>, but use the <code>str()</code> function for a quick-n-dirty, slightly more human readable format:</p>\n\n<pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; str(datetime.now())\n'2011-05-03 17:45:35.177000'\n</code></pre>\n"
  },
  {
    "content": "How can I catch multiple exceptions in one line? (in the &quot;except&quot; block)",
    "chosen": "<p>From <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\" rel=\"noreferrer\">Python Documentation</a>:</p>\n\n<blockquote>\n  <p>An except clause may name multiple exceptions as a parenthesized tuple, for example</p>\n</blockquote>\n\n<pre><code>except (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n</code></pre>\n\n<p>Or, for Python 2 only:</p>\n\n<pre><code>except (IDontLikeYouException, YouAreBeingMeanException), e:\n    pass\n</code></pre>\n\n<p>Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using <code>as</code>.</p>\n",
    "rejected": "<blockquote>\n  <h2>How do I catch multiple exceptions in one line (except block)</h2>\n</blockquote>\n\n<p>Do this:</p>\n\n<pre><code>try:\n    may_raise_specific_errors():\nexcept (SpecificErrorOne, SpecificErrorTwo) as error:\n    handle(error) # might log or have some other default behavior...\n</code></pre>\n\n<p>The parentheses are required due to older syntax that used the commas to assign the error object to a name. The <code>as</code> keyword is used for the assignment. You can use any name for the error object, I prefer <code>error</code> personally.</p>\n\n<h2>Best Practice</h2>\n\n<p>To do this in a manner currently and forward compatible with Python, you need to separate the Exceptions with commas and wrap them with parentheses to differentiate from earlier syntax that assigned the exception instance to a variable name by following the Exception type to be caught with a comma. </p>\n\n<p>Here's an example of simple usage:</p>\n\n<pre><code>import sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError): # the parens are necessary\n    sys.exit(0)\n</code></pre>\n\n<p>I'm specifying only these exceptions to avoid hiding bugs, which if I encounter I expect the full stack trace from.</p>\n\n<p>This is documented here: <a href=\"https://docs.python.org/tutorial/errors.html\" rel=\"noreferrer\">https://docs.python.org/tutorial/errors.html</a></p>\n\n<p>You can assign the exception to a variable, (<code>e</code> is common, but you might prefer a more verbose variable if you have long exception handling or your IDE only highlights selections larger than that, as mine does.) The instance has an args attribute. Here is an example:</p>\n\n<pre><code>import sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError) as err: \n    print(err)\n    print(err.args)\n    sys.exit(0)\n</code></pre>\n\n<p>Note that in Python 3, the <code>err</code> object falls out of scope when the <code>except</code> block is concluded.</p>\n\n<h2>Deprecated</h2>\n\n<p>You may see code that assigns the error with a comma. This usage, the only form available in Python 2.5 and earlier, is deprecated, and if you wish your code to be forward compatible in Python 3, you should update the syntax to use the new form:</p>\n\n<pre><code>import sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError), err: # don't do this in Python 2.6+\n    print err\n    print err.args\n    sys.exit(0)\n</code></pre>\n\n<p>If you see the comma name assignment in your codebase, and you're using Python 2.5 or higher, switch to the new way of doing it so your code remains compatible when you upgrade.</p>\n\n<h2>The <code>suppress</code> context manager</h2>\n\n<p>The accepted answer is really 4 lines of code, minimum:</p>\n\n<pre><code>try:\n    do_something()\nexcept (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n</code></pre>\n\n<p>The <code>try</code>, <code>except</code>, <code>pass</code> lines can be handled in a single line with the <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.suppress\" rel=\"noreferrer\">suppress context manager, available in Python 3.4</a>:</p>\n\n<pre><code>from contextlib import suppress\n\nwith suppress(IDontLikeYouException, YouAreBeingMeanException):\n     do_something()\n</code></pre>\n\n<p>So when you want to <code>pass</code> on certain exceptions, use <code>suppress</code>.</p>\n"
  },
  {
    "content": "How do I copy a file?",
    "chosen": "<p><a href=\"http://docs.python.org/3/library/shutil.html\" rel=\"noreferrer\"><code>shutil</code></a> has many methods you can use. One of which is:</p>\n<pre><code>import shutil\n\nshutil.copyfile(src, dst)\n\n# 2nd option\nshutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp\n</code></pre>\n<ul>\n<li>Copy the contents of the file named <code>src</code> to a file named <code>dst</code>. Both <code>src</code> and <code>dst</code> need to be the entire filename of the files, including path.</li>\n<li>The destination location must be writable; otherwise, an <code>IOError</code> exception will be raised.</li>\n<li>If <code>dst</code> already exists, it will be replaced.</li>\n<li>Special files such as character or block devices and pipes cannot be copied with this function.</li>\n<li>With <code>copy</code>, <code>src</code> and <code>dst</code> are path names given as <code>str</code>s.</li>\n</ul>\n<p>Another <code>shutil</code> method to look at is <a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy2\" rel=\"noreferrer\"><code>shutil.copy2()</code></a>. It's similar but preserves more metadata (e.g. time stamps).</p>\n<p>If you use <code>os.path</code> operations, use <code>copy</code> rather than <code>copyfile</code>. <code>copyfile</code> will only accept strings.</p>\n",
    "rejected": "<p><a href=\"https://docs.python.org/2/library/shutil.html#shutil.copy2\" rel=\"noreferrer\"><code>copy2(src,dst)</code></a> is often more useful than <a href=\"https://docs.python.org/2/library/shutil.html#shutil.copyfile\" rel=\"noreferrer\"><code>copyfile(src,dst)</code></a> because:</p>\n\n<ul>\n<li>it allows <code>dst</code> to be a <em>directory</em> (instead of the complete target filename), in which case the <a href=\"https://docs.python.org/2/library/os.path.html#os.path.basename\" rel=\"noreferrer\">basename</a> of <code>src</code> is used for creating the new file;</li>\n<li>it preserves the original modification and access info (mtime and atime) in the file metadata (however, this comes with a slight overhead).</li>\n</ul>\n\n<p>Here is a short example:</p>\n\n<pre><code>import shutil\nshutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given\nshutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext\n</code></pre>\n"
  },
  {
    "content": "What is __init__.py for?",
    "chosen": "<p>It used to be a required part of a package (<a href=\"https://docs.python.org/3/reference/import.html#regular-packages\" rel=\"noreferrer\">old, pre-3.3 \"regular package\"</a>, not <a href=\"https://docs.python.org/3/reference/import.html#namespace-packages\" rel=\"noreferrer\">newer 3.3+ \"namespace package\"</a>).</p>\n\n<p><a href=\"https://docs.python.org/3/reference/import.html#regular-packages\" rel=\"noreferrer\">Here's the documentation.</a></p>\n\n<blockquote>\n  <p>Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an <code>__init__.py</code> file. When a regular package is imported, this <code>__init__.py</code> file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The <code>__init__.py</code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.</p>\n</blockquote>\n\n<p>But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without <code>__init__.py</code>.</p>\n",
    "rejected": "<p>There are 2 main reasons for <code>__init__.py</code></p>\n<ol>\n<li><p>For convenience: the other users will not need to know your functions' exact location in your package hierarchy (<a href=\"https://docs.python.org/3/reference/import.html#submodules\" rel=\"noreferrer\">documentation</a>).</p>\n<pre><code>your_package/\n  __init__.py\n  file1.py\n  file2.py\n    ...\n  fileN.py\n</code></pre>\n<pre><code># in __init__.py\nfrom .file1 import *\nfrom .file2 import *\n...\nfrom .fileN import *\n</code></pre>\n<pre><code># in file1.py\ndef add():\n    pass\n</code></pre>\n<p>then others can call add() by</p>\n<pre><code> from your_package import add\n</code></pre>\n<p>without knowing file1's inside functions, like</p>\n<pre><code> from your_package.file1 import add\n</code></pre>\n</li>\n<li><p>If you want something to be initialized; for example, logging (which should be put in the top level):</p>\n<pre><code> import logging.config\n logging.config.dictConfig(Your_logging_config)\n</code></pre>\n</li>\n</ol>\n"
  },
  {
    "content": "Convert bytes to a string in Python 3",
    "chosen": "<p><a href=\"https://docs.python.org/3/library/stdtypes.html#bytes.decode\" rel=\"noreferrer\">Decode the <code>bytes</code> object</a> to produce a string:</p>\n<pre><code>&gt;&gt;&gt; b&quot;abcde&quot;.decode(&quot;utf-8&quot;)\n'abcde'\n</code></pre>\n<p>The above example <em>assumes</em> that the <code>bytes</code> object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!</p>\n",
    "rejected": "<p>If you don't know the encoding, then to read binary input into string in Python 3 and Python 2 compatible way, use the ancient MS-DOS <a href=\"https://en.wikipedia.org/wiki/Code_page_437\" rel=\"noreferrer\">CP437</a> encoding:</p>\n\n<pre><code>PY3K = sys.version_info &gt;= (3, 0)\n\nlines = []\nfor line in stream:\n    if not PY3K:\n        lines.append(line)\n    else:\n        lines.append(line.decode('cp437'))\n</code></pre>\n\n<p>Because encoding is unknown, expect non-English symbols to translate to characters of <code>cp437</code> (English characters are not translated, because they match in most single byte encodings and UTF-8).</p>\n\n<p>Decoding arbitrary binary input to UTF-8 is unsafe, because you may get this:</p>\n\n<pre><code>&gt;&gt;&gt; b'\\x00\\x01\\xffsd'.decode('utf-8')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 2: invalid\nstart byte\n</code></pre>\n\n<p>The same applies to <code>latin-1</code>, which was popular (the default?) for Python 2. See the missing points in <a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1#Codepage_layout\" rel=\"noreferrer\">Codepage Layout</a> - it is where Python chokes with infamous <code>ordinal not in range</code>.</p>\n\n<p><strong>UPDATE 20150604</strong>: There are rumors that Python 3 has the <code>surrogateescape</code> error strategy for encoding stuff into binary data without data loss and crashes, but it needs conversion tests, <code>[binary] -&gt; [str] -&gt; [binary]</code>, to validate both performance and reliability.</p>\n\n<p><strong>UPDATE 20170116</strong>: Thanks to comment by Nearoo - there is also a possibility to slash escape all unknown bytes with <code>backslashreplace</code> error handler. That works only for Python 3, so even with this workaround you will still get inconsistent output from different Python versions:</p>\n\n<pre><code>PY3K = sys.version_info &gt;= (3, 0)\n\nlines = []\nfor line in stream:\n    if not PY3K:\n        lines.append(line)\n    else:\n        lines.append(line.decode('utf-8', 'backslashreplace'))\n</code></pre>\n\n<p>See <em><a href=\"https://docs.python.org/3/howto/unicode.html#python-s-unicode-support\" rel=\"noreferrer\">Python’s Unicode Support</a></em> for details.</p>\n\n<p><strong>UPDATE 20170119</strong>: I decided to implement slash escaping decode that works for both Python&nbsp;2 and Python&nbsp;3. It should be slower than the <code>cp437</code> solution, but it should produce <strong>identical results</strong> on every Python version.</p>\n\n<pre><code># --- preparation\n\nimport codecs\n\ndef slashescape(err):\n    \"\"\" codecs error handler. err is UnicodeDecode instance. return\n    a tuple with a replacement for the unencodable part of the input\n    and a position where encoding should continue\"\"\"\n    #print err, dir(err), err.start, err.end, err.object[:err.start]\n    thebyte = err.object[err.start:err.end]\n    repl = u'\\\\x'+hex(ord(thebyte))[2:]\n    return (repl, err.end)\n\ncodecs.register_error('slashescape', slashescape)\n\n# --- processing\n\nstream = [b'\\x80abc']\n\nlines = []\nfor line in stream:\n    lines.append(line.decode('utf-8', 'slashescape'))\n</code></pre>\n"
  },
  {
    "content": "What is the difference between __str__ and __repr__?",
    "chosen": "\n<p><a href=\"https://stackoverflow.com/a/1436756/3798217\">Alex Martelli summarized well</a> but, surprisingly, was too succinct.</p>\n<p>First, let me reiterate the main points in <a href=\"https://stackoverflow.com/users/95810/alex-martelli\">Alex</a>’s post:</p>\n<ul>\n<li>The default implementation is useless (it’s hard to think of one which wouldn’t be, but yeah)</li>\n<li><code>__repr__</code> goal is to be unambiguous</li>\n<li><code>__str__</code> goal is to be readable</li>\n<li>Container’s <code>__str__</code> uses contained objects’ <code>__repr__</code></li>\n</ul>\n<p><strong>Default implementation is useless</strong></p>\n<p>This is mostly a surprise because Python’s defaults tend to be fairly useful. However, in this case, having a default for <code>__repr__</code> which would act like:</p>\n<pre class=\"lang-python prettyprint-override\"><code>return &quot;%s(%r)&quot; % (self.__class__, self.__dict__)\n</code></pre>\n<p>Or in new f-string formatting:</p>\n<pre class=\"lang-python prettyprint-override\"><code>return f&quot;{self.__class__!s}({self.__dict__!r})&quot;\n</code></pre>\n<p>would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if <code>__repr__</code> is defined, and <code>__str__</code> is not, the object will behave as though <code>__str__=__repr__</code>.</p>\n<p>This means, in simple terms: almost every object you implement should have a functional <code>__repr__</code> that’s usable for understanding the object. Implementing <code>__str__</code> is optional: do that if you need a “pretty print” functionality (for example, used by a report generator).</p>\n<p><strong>The goal of <code>__repr__</code> is to be unambiguous</strong></p>\n<p>Let me come right out and say it — I do not believe in debuggers. I don’t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature — most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a</p>\n<pre class=\"lang-python prettyprint-override\"><code>log(INFO, &quot;I am in the weird function and a is&quot;, a, &quot;and b is&quot;, b, &quot;but I got a null C — using default&quot;, default_c)\n</code></pre>\n<p>But you have to do the last step — make sure every object you implement has a useful repr, so code like that can just work. This is why the “eval” thing comes up: if you have enough information so <code>eval(repr(c))==c</code>, that means you know everything there is to know about <code>c</code>. If that’s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about <code>c</code> anyway. I usually use an eval-like format: <code>&quot;MyClass(this=%r,that=%r)&quot; % (self.this,self.that)</code>. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments — but it is a useful form to express “this is everything you need to know about this instance”.</p>\n<p>Note: I used <code>%r</code> above, not <code>%s</code>. You always want to use <code>repr()</code> [or <code>%r</code> formatting character, equivalently] inside <code>__repr__</code> implementation, or you’re defeating the goal of repr. You want to be able to differentiate <code>MyClass(3)</code> and <code>MyClass(&quot;3&quot;)</code>.</p>\n<p><strong>The goal of <code>__str__</code> is to be readable</strong></p>\n<p>Specifically, it is not intended to be unambiguous — notice that <code>str(3)==str(&quot;3&quot;)</code>. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be &quot;2010/4/12 15:35:22&quot;, etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class — as long is it supports readability, it is an improvement.</p>\n<p><strong>Container’s <code>__str__</code> uses contained objects’ <code>__repr__</code></strong></p>\n<p>This seems surprising, doesn’t it? It is a little, but how readable would it be if it used their <code>__str__</code>?</p>\n<pre class=\"lang-python prettyprint-override\"><code>[moshe is, 3, hello\nworld, this is a list, oh I don't know, containing just 4 elements]\n</code></pre>\n<p>Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you’re printing a list, just</p>\n<pre class=\"lang-python prettyprint-override\"><code>print(&quot;[&quot; + &quot;, &quot;.join(lst) + &quot;]&quot;)\n</code></pre>\n<p>(you can probably also figure out what to do about dictionaries).</p>\n<p><strong>Summary</strong></p>\n<p>Implement <code>__repr__</code> for any class you implement. This should be second nature. Implement <code>__str__</code> if you think it would be useful to have a string version which errs on the side of readability.</p>\n",
    "rejected": "<h2>What is the difference between <code>__str__</code> and <code>__repr__</code> in Python?</h2>\n<p><code>__str__</code> (read as &quot;dunder (double-underscore) string&quot;) and <code>__repr__</code> (read as &quot;dunder-repper&quot; (for &quot;representation&quot;)) are both special methods that return strings based on the state of the object.</p>\n<p><code>__repr__</code> provides backup behavior if <code>__str__</code> is missing.</p>\n<p>So one should first write a <code>__repr__</code> that allows you to reinstantiate an equivalent object from the string it returns e.g. using <code>eval</code> or by typing it in character-for-character in a Python shell.</p>\n<p>At any time later, one can write a <code>__str__</code> for a user-readable string representation of the instance, when one believes it to be necessary.</p>\n<h3><code>__str__</code></h3>\n<p>If you print an object, or pass it to <code>format</code>, <code>str.format</code>, or <code>str</code>, then if a <code>__str__</code> method is defined, that method will be called, otherwise, <code>__repr__</code> will be used.</p>\n<h3><code>__repr__</code></h3>\n<p>The <code>__repr__</code> method is called by the builtin function <code>repr</code> and is what is echoed on your python shell when it evaluates an expression that returns an object.</p>\n<p>Since it provides a backup for <code>__str__</code>, if you can only write one, start with <code>__repr__</code></p>\n<p>Here's the builtin help on <code>repr</code>:</p>\n<pre><code>repr(...)\n    repr(object) -&gt; string\n    \n    Return the canonical string representation of the object.\n    For most object types, eval(repr(object)) == object.\n</code></pre>\n<p>That is, for most objects, if you type in what is printed by <code>repr</code>, you should be able to create an equivalent object. <em>But this is not the default implementation.</em></p>\n<h3>Default Implementation of <code>__repr__</code></h3>\n<p>The default object <code>__repr__</code> is (<a href=\"https://github.com/python/cpython/blob/v3.7.3/Objects/object.c#L496\" rel=\"noreferrer\">C Python source</a>) something like:</p>\n<pre><code>def __repr__(self):\n    return '&lt;{0}.{1} object at {2}&gt;'.format(\n      type(self).__module__, type(self).__qualname__, hex(id(self)))\n</code></pre>\n<p>That means by default you'll print the module the object is from, the class name, and the hexadecimal representation of its location in memory - for example:</p>\n<pre><code>&lt;__main__.Foo object at 0x7f80665abdd0&gt;\n</code></pre>\n<p>This information isn't very useful, but there's no way to derive how one might accurately create a canonical representation of any given instance, and it's better than nothing, at least telling us how we might uniquely identify it in memory.</p>\n<h3>How can <code>__repr__</code> be useful?</h3>\n<p>Let's look at how useful it can be, using the Python shell and <code>datetime</code> objects. First we need to import the <code>datetime</code> module:</p>\n<pre><code>import datetime\n</code></pre>\n<p>If we call <code>datetime.now</code> in the shell, we'll see everything we need to recreate an equivalent datetime object. This is created by the datetime <code>__repr__</code>:</p>\n<pre><code>&gt;&gt;&gt; datetime.datetime.now()\ndatetime.datetime(2015, 1, 24, 20, 5, 36, 491180)\n</code></pre>\n<p>If we print a datetime object, we see a nice human readable (in fact, ISO) format. This is implemented by datetime's <code>__str__</code>:</p>\n<pre><code>&gt;&gt;&gt; print(datetime.datetime.now())\n2015-01-24 20:05:44.977951\n</code></pre>\n<p>It is a simple matter to recreate the object we lost because we didn't assign it to a variable by copying and pasting from the <code>__repr__</code> output, and then printing it, and we get it in the same human readable output as the other object:</p>\n<pre><code>&gt;&gt;&gt; the_past = datetime.datetime(2015, 1, 24, 20, 5, 36, 491180)\n&gt;&gt;&gt; print(the_past)\n2015-01-24 20:05:36.491180\n</code></pre>\n<h3>How do I implement them?</h3>\n<p>As you're developing, you'll want to be able to reproduce objects in the same state, if possible. This, for example, is how the datetime object defines <code>__repr__</code> (<a href=\"https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1876\" rel=\"noreferrer\">Python source</a>). It is fairly complex, because of all of the attributes needed to reproduce such an object:</p>\n<pre><code>def __repr__(self):\n    &quot;&quot;&quot;Convert to formal string, for repr().&quot;&quot;&quot;\n    L = [self._year, self._month, self._day,  # These are never zero\n         self._hour, self._minute, self._second, self._microsecond]\n    if L[-1] == 0:\n        del L[-1]\n    if L[-1] == 0:\n        del L[-1]\n    s = &quot;%s.%s(%s)&quot; % (self.__class__.__module__,\n                       self.__class__.__qualname__,\n                       &quot;, &quot;.join(map(str, L)))\n    if self._tzinfo is not None:\n        assert s[-1:] == &quot;)&quot;\n        s = s[:-1] + &quot;, tzinfo=%r&quot; % self._tzinfo + &quot;)&quot;\n    if self._fold:\n        assert s[-1:] == &quot;)&quot;\n        s = s[:-1] + &quot;, fold=1)&quot;\n    return s\n</code></pre>\n<p>If you want your object to have a more human readable representation, you can implement <code>__str__</code> next. Here's how the datetime object (<a href=\"https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1895\" rel=\"noreferrer\">Python source</a>) implements <code>__str__</code>, which it easily does because it already has a function to display it in ISO format:</p>\n<pre><code>def __str__(self):\n    &quot;Convert to string, for str().&quot;\n    return self.isoformat(sep=' ')\n</code></pre>\n<h4>Set <code>__repr__ = __str__</code>?</h4>\n<p>This is a critique of another answer here that suggests setting <code>__repr__ = __str__</code>.</p>\n<p>Setting <code>__repr__ = __str__</code> is silly - <code>__repr__</code> is a fallback for <code>__str__</code> and a <code>__repr__</code>, written for developers usage in debugging, should be written before you write a <code>__str__</code>.</p>\n<p>You need a <code>__str__</code> only when you need a textual representation of the object.</p>\n<h3>Conclusion</h3>\n<p>Define <code>__repr__</code> for objects you write so you and other developers have a reproducible example when using it as you develop. Define <code>__str__</code> when you need a human readable string representation of it.</p>\n"
  },
  {
    "content": "How do I select rows from a DataFrame based on column values?",
    "chosen": "<p>To select rows whose column value equals a scalar, <code>some_value</code>, use <code>==</code>:</p>\n<pre><code>df.loc[df['column_name'] == some_value]\n</code></pre>\n<p>To select rows whose column value is in an iterable, <code>some_values</code>, use <code>isin</code>:</p>\n<pre><code>df.loc[df['column_name'].isin(some_values)]\n</code></pre>\n<p>Combine multiple conditions with <code>&amp;</code>:</p>\n<pre><code>df.loc[(df['column_name'] &gt;= A) &amp; (df['column_name'] &lt;= B)]\n</code></pre>\n<p>Note the parentheses. Due to Python's <a href=\"https://docs.python.org/3/reference/expressions.html#operator-precedence\" rel=\"noreferrer\">operator precedence rules</a>, <code>&amp;</code> binds more tightly than <code>&lt;=</code> and <code>&gt;=</code>. Thus, the parentheses in the last example are necessary. Without the parentheses</p>\n<pre><code>df['column_name'] &gt;= A &amp; df['column_name'] &lt;= B\n</code></pre>\n<p>is parsed as</p>\n<pre><code>df['column_name'] &gt;= (A &amp; df['column_name']) &lt;= B\n</code></pre>\n<p>which results in a <a href=\"https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o\">Truth value of a Series is ambiguous error</a>.</p>\n<hr />\n<p>To select rows whose column value <em>does not equal</em> <code>some_value</code>, use <code>!=</code>:</p>\n<pre><code>df.loc[df['column_name'] != some_value]\n</code></pre>\n<p>The <code>isin</code> returns a boolean Series, so to select rows whose value is <em>not</em> in <code>some_values</code>, negate the boolean Series using <code>~</code>:</p>\n<pre><code>df = df.loc[~df['column_name'].isin(some_values)] # .loc is not in-place replacement\n</code></pre>\n<hr />\n<p>For example,</p>\n<pre><code>import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split(),\n                   'C': np.arange(8), 'D': np.arange(8) * 2})\nprint(df)\n#      A      B  C   D\n# 0  foo    one  0   0\n# 1  bar    one  1   2\n# 2  foo    two  2   4\n# 3  bar  three  3   6\n# 4  foo    two  4   8\n# 5  bar    two  5  10\n# 6  foo    one  6  12\n# 7  foo  three  7  14\n\nprint(df.loc[df['A'] == 'foo'])\n</code></pre>\n<p>yields</p>\n<pre><code>     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<hr />\n<p>If you have multiple values you want to include, put them in a\nlist (or more generally, any iterable) and use <code>isin</code>:</p>\n<pre><code>print(df.loc[df['B'].isin(['one','three'])])\n</code></pre>\n<p>yields</p>\n<pre><code>     A      B  C   D\n0  foo    one  0   0\n1  bar    one  1   2\n3  bar  three  3   6\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<hr />\n<p>Note, however, that if you wish to do this many times, it is more efficient to\nmake an index first, and then use <code>df.loc</code>:</p>\n<pre><code>df = df.set_index(['B'])\nprint(df.loc['one'])\n</code></pre>\n<p>yields</p>\n<pre><code>       A  C   D\nB              \none  foo  0   0\none  bar  1   2\none  foo  6  12\n</code></pre>\n<p>or, to include multiple values from the index use <code>df.index.isin</code>:</p>\n<pre><code>df.loc[df.index.isin(['one','two'])]\n</code></pre>\n<p>yields</p>\n<pre><code>       A  C   D\nB              \none  foo  0   0\none  bar  1   2\ntwo  foo  2   4\ntwo  foo  4   8\ntwo  bar  5  10\none  foo  6  12\n</code></pre>\n",
    "rejected": "<h3>More flexibility using <code>.query</code> with pandas &gt;= 0.25.0:</h3>\n<p>Since pandas &gt;= 0.25.0 we can use the <code>query</code> method to filter dataframes with pandas methods and even column names which have spaces. Normally the spaces in column names would give an error, but now we can solve that using a backtick (`) - see <a href=\"https://github.com/pandas-dev/pandas/issues/6508\" rel=\"noreferrer\">GitHub</a>:</p>\n<pre><code># Example dataframe\ndf = pd.DataFrame({'Sender email':['ex@example.com', &quot;reply@shop.com&quot;, &quot;buy@shop.com&quot;]})\n\n     Sender email\n0  ex@example.com\n1  reply@shop.com\n2    buy@shop.com\n</code></pre>\n<p>Using <code>.query</code> with method <code>str.endswith</code>:</p>\n<pre><code>df.query('`Sender email`.str.endswith(&quot;@shop.com&quot;)')\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>     Sender email\n1  reply@shop.com\n2    buy@shop.com\n</code></pre>\n<hr />\n<p>Also we can use local variables by prefixing it with an <code>@</code> in our query:</p>\n<pre><code>domain = 'shop.com'\ndf.query('`Sender email`.str.endswith(@domain)')\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>     Sender email\n1  reply@shop.com\n2    buy@shop.com\n</code></pre>\n"
  },
  {
    "content": "How can I add new keys to a dictionary?",
    "chosen": "<p>You create a new key/value pair on a dictionary by assigning a value to that key</p>\n<pre><code>d = {'key': 'value'}\nprint(d)  # {'key': 'value'}\n\nd['mynewkey'] = 'mynewvalue'\n\nprint(d)  # {'key': 'value', 'mynewkey': 'mynewvalue'}\n</code></pre>\n<p>If the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten.</p>\n",
    "rejected": "<p>If you want to add a dictionary within a dictionary you can do it this way. </p>\n\n<p>Example: Add a new entry to your dictionary &amp; sub dictionary</p>\n\n<pre><code>dictionary = {}\ndictionary[\"new key\"] = \"some new entry\" # add new dictionary entry\ndictionary[\"dictionary_within_a_dictionary\"] = {} # this is required by python\ndictionary[\"dictionary_within_a_dictionary\"][\"sub_dict\"] = {\"other\" : \"dictionary\"}\nprint (dictionary)\n</code></pre>\n\n<p><strong>Output:</strong></p>\n\n<pre><code>{'new key': 'some new entry', 'dictionary_within_a_dictionary': {'sub_dict': {'other': 'dictionarly'}}}\n</code></pre>\n\n<p><strong>NOTE:</strong> Python requires that you first add a sub  </p>\n\n<pre><code>dictionary[\"dictionary_within_a_dictionary\"] = {}\n</code></pre>\n\n<p>before adding entries.</p>\n"
  },
  {
    "content": "Does Python have a string &#39;contains&#39; substring method?",
    "chosen": "<p>Use the <a href=\"https://docs.python.org/reference/expressions.html#membership-test-details\" rel=\"noreferrer\"><code>in</code> operator</a>:</p>\n<pre><code>if &quot;blah&quot; not in somestring: \n    continue\n</code></pre>\n<p>Note: This is case-sensitive.</p>\n",
    "rejected": "<p>So apparently there is nothing similar for vector-wise comparison. An obvious Python way to do so would be:</p>\n\n<pre><code>names = ['bob', 'john', 'mike']\nany(st in 'bob and john' for st in names) \n&gt;&gt; True\n\nany(st in 'mary and jane' for st in names) \n&gt;&gt; False\n</code></pre>\n"
  }
]